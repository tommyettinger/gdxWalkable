// Generated by Haxe 3.4.2
package hxDaedalus.ai;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class AStar extends haxe.lang.HxObject
{
	public AStar(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public AStar()
	{
		hxDaedalus.ai.AStar.__hx_ctor_hxDaedalus_ai_AStar(this);
	}
	
	
	public static void __hx_ctor_hxDaedalus_ai_AStar(hxDaedalus.ai.AStar __hx_this)
	{
		__hx_this.iterEdge = new hxDaedalus.iterators.FromFaceToInnerEdges();
	}
	
	
	
	
	public double _radius;
	
	
	
	public hxDaedalus.data.Mesh _mesh;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> closedFaces;
	
	public haxe.root.Array<hxDaedalus.data.Face> sortedOpenedFaces;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> openedFaces;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Edge> entryEdges;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> entryX;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> entryY;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> scoreF;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> scoreG;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> scoreH;
	
	public haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Face> predecessor;
	
	public hxDaedalus.iterators.FromFaceToInnerEdges iterEdge;
	
	public double radiusSquared;
	
	public double diameter;
	
	public double diameterSquared;
	
	public hxDaedalus.data.Face fromFace;
	
	public hxDaedalus.data.Face toFace;
	
	public hxDaedalus.data.Face curFace;
	
	public void dispose()
	{
		this._mesh = null;
		this.closedFaces = null;
		this.sortedOpenedFaces = null;
		this.openedFaces = null;
		this.entryEdges = null;
		this.entryX = null;
		this.entryY = null;
		this.scoreF = null;
		this.scoreG = null;
		this.scoreH = null;
		this.predecessor = null;
	}
	
	
	public double get_radius()
	{
		return this._radius;
	}
	
	
	public double set_radius(double value)
	{
		this._radius = value;
		this.radiusSquared = ( this._radius * this._radius );
		this.diameter = ( this._radius * 2 );
		this.diameterSquared = ( this.diameter * this.diameter );
		return value;
	}
	
	
	public hxDaedalus.data.Mesh set_mesh(hxDaedalus.data.Mesh value)
	{
		this._mesh = value;
		return value;
	}
	
	
	public void findPath(double fromX, double fromY, double toX, double toY, haxe.root.Array<hxDaedalus.data.Face> resultListFaces, haxe.root.Array<hxDaedalus.data.Edge> resultListEdges)
	{
		this.closedFaces = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.sortedOpenedFaces = new haxe.root.Array<hxDaedalus.data.Face>();
		this.openedFaces = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) new haxe.ds.ObjectMap<hxDaedalus.data.Face, Object>());
		this.entryEdges = new haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Edge>();
		this.entryX = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.entryY = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.scoreF = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.scoreG = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.scoreH = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
		this.predecessor = new haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Face>();
		hxDaedalus.data.math.Intersection loc;
		hxDaedalus.data.Edge locEdge;
		hxDaedalus.data.Vertex locVertex;
		double distance = 0.0;
		hxDaedalus.data.math.Point2D p1 = null;
		hxDaedalus.data.math.Point2D p2 = null;
		hxDaedalus.data.math.Point2D p3 = null;
		loc = hxDaedalus.data.math.Geom2D.locatePosition(fromX, fromY, this._mesh);
		switch (loc.index)
		{
			case 0:
			{
				return ;
			}
			
			
			case 1:
			{
				hxDaedalus.data.Edge edge = ((hxDaedalus.data.Edge) (loc.params[0]) );
				{
					locEdge = edge;
					if (locEdge.get_isConstrained()) 
					{
						return ;
					}
					
					this.fromFace = locEdge.get_leftFace();
				}
				
				break;
			}
			
			
			case 2:
			{
				this.fromFace = ((hxDaedalus.data.Face) (loc.params[0]) );
				break;
			}
			
			
			case 3:
			{
				break;
			}
			
			
		}
		
		loc = hxDaedalus.data.math.Geom2D.locatePosition(toX, toY, this._mesh);
		switch (loc.index)
		{
			case 0:
			{
				hxDaedalus.data.Vertex vertex1 = ((hxDaedalus.data.Vertex) (loc.params[0]) );
				{
					locVertex = vertex1;
					this.toFace = locVertex.get_edge().get_leftFace();
				}
				
				break;
			}
			
			
			case 1:
			{
				hxDaedalus.data.Edge edge1 = ((hxDaedalus.data.Edge) (loc.params[0]) );
				{
					locEdge = edge1;
					this.toFace = locEdge.get_leftFace();
				}
				
				break;
			}
			
			
			case 2:
			{
				this.toFace = ((hxDaedalus.data.Face) (loc.params[0]) );
				break;
			}
			
			
			case 3:
			{
				break;
			}
			
			
		}
		
		this.sortedOpenedFaces.push(this.fromFace);
		this.entryEdges.set(this.fromFace, null);
		this.entryX.set(this.fromFace, fromX);
		this.entryY.set(this.fromFace, fromY);
		this.scoreG.set(this.fromFace, 0);
		double dist = java.lang.Math.sqrt(( ( (( toX - fromX )) * (( toX - fromX )) ) + ( (( toY - fromY )) * (( toY - fromY )) ) ));
		this.scoreH.set(this.fromFace, dist);
		this.scoreF.set(this.fromFace, dist);
		hxDaedalus.data.Edge innerEdge;
		hxDaedalus.data.Face neighbourFace;
		double f;
		double g;
		double h;
		hxDaedalus.data.math.Point2D fromPoint = new hxDaedalus.data.math.Point2D(null, null);
		hxDaedalus.data.math.Point2D entryPoint = new hxDaedalus.data.math.Point2D(null, null);
		hxDaedalus.data.math.Point2D distancePoint = new hxDaedalus.data.math.Point2D(null, null);
		boolean fillDatas;
		while (true)
		{
			if (( this.sortedOpenedFaces.length == 0 )) 
			{
				this.curFace = null;
				break;
			}
			
			this.curFace = ((hxDaedalus.data.Face) (this.sortedOpenedFaces.pop()) );
			if (( this.curFace == this.toFace )) 
			{
				break;
			}
			
			this.iterEdge.set_fromFace(this.curFace);
			while (true)
			{
				innerEdge = this.iterEdge.next();
				if ( ! ((( innerEdge != null ))) ) 
				{
					break;
				}
				
				if (innerEdge.get_isConstrained()) 
				{
					continue;
				}
				
				neighbourFace = innerEdge.get_rightFace();
				if (( ! (haxe.lang.Runtime.toBool(this.closedFaces.get(neighbourFace))) ))
				{
					if (( ( ( this.curFace != this.fromFace ) && ( this._radius > 0 ) ) &&  ! (this.isWalkableByRadius(((hxDaedalus.data.Edge) (this.entryEdges.get(this.curFace)) ), this.curFace, innerEdge))  ))
					{
						continue;
					}
					
					fromPoint.x = haxe.lang.Runtime.toDouble(this.entryX.get(this.curFace));
					fromPoint.y = haxe.lang.Runtime.toDouble(this.entryY.get(this.curFace));
					entryPoint.x = ( (( innerEdge.get_originVertex().get_pos().x + innerEdge.get_destinationVertex().get_pos().x )) / 2 );
					entryPoint.y = ( (( innerEdge.get_originVertex().get_pos().y + innerEdge.get_destinationVertex().get_pos().y )) / 2 );
					distancePoint.x = ( entryPoint.x - toX );
					distancePoint.y = ( entryPoint.y - toY );
					h = distancePoint.get_length();
					distancePoint.x = ( fromPoint.x - entryPoint.x );
					distancePoint.y = ( fromPoint.y - entryPoint.y );
					g = haxe.lang.Runtime.toDouble(haxe.lang.Runtime.plus(this.scoreG.get(this.curFace), distancePoint.get_length()));
					f = ( h + g );
					fillDatas = false;
					if (( haxe.lang.Runtime.eq(this.openedFaces.get(neighbourFace), null) || ( ! (haxe.lang.Runtime.toBool(this.openedFaces.get(neighbourFace))) ) ))
					{
						this.sortedOpenedFaces.push(neighbourFace);
						this.openedFaces.set(neighbourFace, true);
						fillDatas = true;
					}
					else
					{
						if (( haxe.lang.Runtime.compare(this.scoreF.get(neighbourFace), f) > 0 ))
						{
							fillDatas = true;
						}
						
					}
					
					if (fillDatas) 
					{
						this.entryEdges.set(neighbourFace, innerEdge);
						{
							double v = entryPoint.x;
							this.entryX.set(neighbourFace, v);
						}
						
						{
							double v1 = entryPoint.y;
							this.entryY.set(neighbourFace, v1);
						}
						
						this.scoreF.set(neighbourFace, f);
						this.scoreG.set(neighbourFace, g);
						this.scoreH.set(neighbourFace, h);
						{
							hxDaedalus.data.Face v2 = this.curFace;
							this.predecessor.set(neighbourFace, v2);
						}
						
					}
					
				}
				
			}
			
			this.openedFaces.set(this.curFace, false);
			this.closedFaces.set(this.curFace, true);
			this.sortedOpenedFaces.sort(new haxe.lang.Closure(this, "sortingFaces"));
		}
		
		if (( this.curFace == null )) 
		{
			return ;
		}
		
		resultListFaces.push(this.curFace);
		while (( this.curFace != this.fromFace ))
		{
			resultListEdges.unshift(((hxDaedalus.data.Edge) (this.entryEdges.get(this.curFace)) ));
			this.curFace = ((hxDaedalus.data.Face) (this.predecessor.get(this.curFace)) );
			resultListFaces.unshift(this.curFace);
		}
		
	}
	
	
	public int sortingFaces(hxDaedalus.data.Face a, hxDaedalus.data.Face b)
	{
		if (haxe.lang.Runtime.eq(this.scoreF.get(a), this.scoreF.get(b)))
		{
			return 0;
		}
		else
		{
			if (( haxe.lang.Runtime.compare(this.scoreF.get(a), this.scoreF.get(b)) < 0 ))
			{
				return 1;
			}
			else
			{
				return -1;
			}
			
		}
		
	}
	
	
	public boolean isWalkableByRadius(hxDaedalus.data.Edge fromEdge, hxDaedalus.data.Face throughFace, hxDaedalus.data.Edge toEdge)
	{
		hxDaedalus.data.Vertex vA = null;
		hxDaedalus.data.Vertex vB = null;
		hxDaedalus.data.Vertex vC = null;
		if (( fromEdge.get_originVertex() == toEdge.get_originVertex() )) 
		{
			vA = fromEdge.get_destinationVertex();
			vB = toEdge.get_destinationVertex();
			vC = fromEdge.get_originVertex();
		}
		else
		{
			if (( fromEdge.get_destinationVertex() == toEdge.get_destinationVertex() )) 
			{
				vA = fromEdge.get_originVertex();
				vB = toEdge.get_originVertex();
				vC = fromEdge.get_destinationVertex();
			}
			else
			{
				if (( fromEdge.get_originVertex() == toEdge.get_destinationVertex() )) 
				{
					vA = fromEdge.get_destinationVertex();
					vB = toEdge.get_originVertex();
					vC = fromEdge.get_originVertex();
				}
				else
				{
					if (( fromEdge.get_destinationVertex() == toEdge.get_originVertex() )) 
					{
						vA = fromEdge.get_originVertex();
						vB = toEdge.get_destinationVertex();
						vC = fromEdge.get_destinationVertex();
					}
					
				}
				
			}
			
		}
		
		double dot;
		boolean result = false;
		double distSquared;
		dot = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vB.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vB.get_pos().y - vA.get_pos().y )) ) );
		if (( dot <= 0 )) 
		{
			distSquared = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vC.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vC.get_pos().y - vA.get_pos().y )) ) );
			if (( distSquared >= this.diameterSquared )) 
			{
				return true;
			}
			else
			{
				return false;
			}
			
		}
		
		dot = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vA.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vA.get_pos().y - vB.get_pos().y )) ) );
		if (( dot <= 0 )) 
		{
			distSquared = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vC.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vC.get_pos().y - vB.get_pos().y )) ) );
			if (( distSquared >= this.diameterSquared )) 
			{
				return true;
			}
			else
			{
				return false;
			}
			
		}
		
		hxDaedalus.data.Edge adjEdge;
		if (( ( ( ( throughFace.get_edge() != fromEdge ) && ( throughFace.get_edge().get_oppositeEdge() != fromEdge ) ) && ( throughFace.get_edge() != toEdge ) ) && ( throughFace.get_edge().get_oppositeEdge() != toEdge ) )) 
		{
			adjEdge = throughFace.get_edge();
		}
		else
		{
			if (( ( ( ( throughFace.get_edge().get_nextLeftEdge() != fromEdge ) && ( throughFace.get_edge().get_nextLeftEdge().get_oppositeEdge() != fromEdge ) ) && ( throughFace.get_edge().get_nextLeftEdge() != toEdge ) ) && ( throughFace.get_edge().get_nextLeftEdge().get_oppositeEdge() != toEdge ) )) 
			{
				adjEdge = throughFace.get_edge().get_nextLeftEdge();
			}
			else
			{
				adjEdge = throughFace.get_edge().get_prevLeftEdge();
			}
			
		}
		
		if (adjEdge.get_isConstrained()) 
		{
			hxDaedalus.data.math.Point2D proj = new hxDaedalus.data.math.Point2D(vC.get_pos().x, vC.get_pos().y);
			hxDaedalus.data.math.Geom2D.projectOrthogonaly(proj, adjEdge);
			distSquared = ( ( (( proj.x - vC.get_pos().x )) * (( proj.x - vC.get_pos().x )) ) + ( (( proj.y - vC.get_pos().y )) * (( proj.y - vC.get_pos().y )) ) );
			if (( distSquared >= this.diameterSquared )) 
			{
				return true;
			}
			else
			{
				return false;
			}
			
		}
		else
		{
			double distSquaredA = ( ( (( vC.get_pos().x - vA.get_pos().x )) * (( vC.get_pos().x - vA.get_pos().x )) ) + ( (( vC.get_pos().y - vA.get_pos().y )) * (( vC.get_pos().y - vA.get_pos().y )) ) );
			double distSquaredB = ( ( (( vC.get_pos().x - vB.get_pos().x )) * (( vC.get_pos().x - vB.get_pos().x )) ) + ( (( vC.get_pos().y - vB.get_pos().y )) * (( vC.get_pos().y - vB.get_pos().y )) ) );
			if (( ( distSquaredA < this.diameterSquared ) || ( distSquaredB < this.diameterSquared ) )) 
			{
				return false;
			}
			else
			{
				haxe.root.Array<hxDaedalus.data.Face> vFaceToCheck = new haxe.root.Array<hxDaedalus.data.Face>();
				haxe.root.Array<hxDaedalus.data.Edge> vFaceIsFromEdge = new haxe.root.Array<hxDaedalus.data.Edge>();
				haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object> facesDone = new haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>();
				vFaceIsFromEdge.push(adjEdge);
				if (( adjEdge.get_leftFace() == throughFace )) 
				{
					vFaceToCheck.push(adjEdge.get_rightFace());
					facesDone.set(adjEdge.get_rightFace(), true);
				}
				else
				{
					vFaceToCheck.push(adjEdge.get_leftFace());
					facesDone.set(adjEdge.get_leftFace(), true);
				}
				
				hxDaedalus.data.Face currFace;
				hxDaedalus.data.Edge faceFromEdge;
				hxDaedalus.data.Edge currEdgeA;
				hxDaedalus.data.Face nextFaceA;
				hxDaedalus.data.Edge currEdgeB;
				hxDaedalus.data.Face nextFaceB;
				while (( vFaceToCheck.length > 0 ))
				{
					currFace = ((hxDaedalus.data.Face) (vFaceToCheck.shift()) );
					faceFromEdge = ((hxDaedalus.data.Edge) (vFaceIsFromEdge.shift()) );
					if (( ( currFace.get_edge() == faceFromEdge ) || ( currFace.get_edge() == faceFromEdge.get_oppositeEdge() ) )) 
					{
						currEdgeA = currFace.get_edge().get_nextLeftEdge();
						currEdgeB = currFace.get_edge().get_nextLeftEdge().get_nextLeftEdge();
					}
					else
					{
						if (( ( currFace.get_edge().get_nextLeftEdge() == faceFromEdge ) || ( currFace.get_edge().get_nextLeftEdge() == faceFromEdge.get_oppositeEdge() ) )) 
						{
							currEdgeA = currFace.get_edge();
							currEdgeB = currFace.get_edge().get_nextLeftEdge().get_nextLeftEdge();
						}
						else
						{
							currEdgeA = currFace.get_edge();
							currEdgeB = currFace.get_edge().get_nextLeftEdge();
						}
						
					}
					
					if (( currEdgeA.get_leftFace() == currFace )) 
					{
						nextFaceA = currEdgeA.get_rightFace();
					}
					else
					{
						nextFaceA = currEdgeA.get_leftFace();
					}
					
					if (( currEdgeB.get_leftFace() == currFace )) 
					{
						nextFaceB = currEdgeB.get_rightFace();
					}
					else
					{
						nextFaceB = currEdgeB.get_leftFace();
					}
					
					if (( ( ! (haxe.lang.Runtime.toBool(facesDone.get(nextFaceA))) ) && ( hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(vC, currEdgeA) < this.diameterSquared ) ))
					{
						if (currEdgeA.get_isConstrained()) 
						{
							return false;
						}
						else
						{
							vFaceToCheck.push(nextFaceA);
							vFaceIsFromEdge.push(currEdgeA);
							facesDone.set(nextFaceA, true);
						}
						
					}
					
					if (( ( ! (haxe.lang.Runtime.toBool(facesDone.get(nextFaceB))) ) && ( hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(vC, currEdgeB) < this.diameterSquared ) ))
					{
						if (currEdgeB.get_isConstrained()) 
						{
							return false;
						}
						else
						{
							vFaceToCheck.push(nextFaceB);
							vFaceIsFromEdge.push(currEdgeB);
							facesDone.set(nextFaceB, true);
						}
						
					}
					
				}
				
				return true;
			}
			
		}
		
	}
	
	
	@Override public double __hx_setField_f(java.lang.String field, double value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case -2099968614:
				{
					if (field.equals("diameterSquared")) 
					{
						this.diameterSquared = value;
						return value;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						this.set_radius(value);
						return value;
					}
					
					break;
				}
				
				
				case -233204595:
				{
					if (field.equals("diameter")) 
					{
						this.diameter = value;
						return value;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						this._radius = value;
						return value;
					}
					
					break;
				}
				
				
				case -677179915:
				{
					if (field.equals("radiusSquared")) 
					{
						this.radiusSquared = value;
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField_f(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_setField(java.lang.String field, java.lang.Object value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1125625021:
				{
					if (field.equals("curFace")) 
					{
						this.curFace = ((hxDaedalus.data.Face) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						this.set_radius(haxe.lang.Runtime.toDouble(value));
						return value;
					}
					
					break;
				}
				
				
				case -869293192:
				{
					if (field.equals("toFace")) 
					{
						this.toFace = ((hxDaedalus.data.Face) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						this._radius = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case -1245086425:
				{
					if (field.equals("fromFace")) 
					{
						this.fromFace = ((hxDaedalus.data.Face) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 3347949:
				{
					if (field.equals("mesh")) 
					{
						this.set_mesh(((hxDaedalus.data.Mesh) (value) ));
						return value;
					}
					
					break;
				}
				
				
				case -2099968614:
				{
					if (field.equals("diameterSquared")) 
					{
						this.diameterSquared = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 91082444:
				{
					if (field.equals("_mesh")) 
					{
						this._mesh = ((hxDaedalus.data.Mesh) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -233204595:
				{
					if (field.equals("diameter")) 
					{
						this.diameter = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 616703914:
				{
					if (field.equals("closedFaces")) 
					{
						this.closedFaces = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -677179915:
				{
					if (field.equals("radiusSquared")) 
					{
						this.radiusSquared = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 63996880:
				{
					if (field.equals("sortedOpenedFaces")) 
					{
						this.sortedOpenedFaces = ((haxe.root.Array<hxDaedalus.data.Face>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 1181683957:
				{
					if (field.equals("iterEdge")) 
					{
						this.iterEdge = ((hxDaedalus.iterators.FromFaceToInnerEdges) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 512628429:
				{
					if (field.equals("openedFaces")) 
					{
						this.openedFaces = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1925032183:
				{
					if (field.equals("predecessor")) 
					{
						this.predecessor = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Face>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1989818108:
				{
					if (field.equals("entryEdges")) 
					{
						this.entryEdges = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, hxDaedalus.data.Edge>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -907766794:
				{
					if (field.equals("scoreH")) 
					{
						this.scoreH = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1298266586:
				{
					if (field.equals("entryX")) 
					{
						this.entryX = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -907766795:
				{
					if (field.equals("scoreG")) 
					{
						this.scoreG = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1298266585:
				{
					if (field.equals("entryY")) 
					{
						this.entryY = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -907766796:
				{
					if (field.equals("scoreF")) 
					{
						this.scoreF = ((haxe.ds.ObjectMap<hxDaedalus.data.Face, java.lang.Object>) (value) );
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_getField(java.lang.String field, boolean throwErrors, boolean isCheck, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1566142678:
				{
					if (field.equals("isWalkableByRadius")) 
					{
						return new haxe.lang.Closure(this, "isWalkableByRadius");
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case 96567954:
				{
					if (field.equals("sortingFaces")) 
					{
						return new haxe.lang.Closure(this, "sortingFaces");
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						return this._radius;
					}
					
					break;
				}
				
				
				case -679327362:
				{
					if (field.equals("findPath")) 
					{
						return new haxe.lang.Closure(this, "findPath");
					}
					
					break;
				}
				
				
				case 91082444:
				{
					if (field.equals("_mesh")) 
					{
						return this._mesh;
					}
					
					break;
				}
				
				
				case 1415348138:
				{
					if (field.equals("set_mesh")) 
					{
						return new haxe.lang.Closure(this, "set_mesh");
					}
					
					break;
				}
				
				
				case 616703914:
				{
					if (field.equals("closedFaces")) 
					{
						return this.closedFaces;
					}
					
					break;
				}
				
				
				case -1216062705:
				{
					if (field.equals("set_radius")) 
					{
						return new haxe.lang.Closure(this, "set_radius");
					}
					
					break;
				}
				
				
				case 63996880:
				{
					if (field.equals("sortedOpenedFaces")) 
					{
						return this.sortedOpenedFaces;
					}
					
					break;
				}
				
				
				case 1142099355:
				{
					if (field.equals("get_radius")) 
					{
						return new haxe.lang.Closure(this, "get_radius");
					}
					
					break;
				}
				
				
				case 512628429:
				{
					if (field.equals("openedFaces")) 
					{
						return this.openedFaces;
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						return new haxe.lang.Closure(this, "dispose");
					}
					
					break;
				}
				
				
				case -1989818108:
				{
					if (field.equals("entryEdges")) 
					{
						return this.entryEdges;
					}
					
					break;
				}
				
				
				case 1125625021:
				{
					if (field.equals("curFace")) 
					{
						return this.curFace;
					}
					
					break;
				}
				
				
				case -1298266586:
				{
					if (field.equals("entryX")) 
					{
						return this.entryX;
					}
					
					break;
				}
				
				
				case -869293192:
				{
					if (field.equals("toFace")) 
					{
						return this.toFace;
					}
					
					break;
				}
				
				
				case -1298266585:
				{
					if (field.equals("entryY")) 
					{
						return this.entryY;
					}
					
					break;
				}
				
				
				case -1245086425:
				{
					if (field.equals("fromFace")) 
					{
						return this.fromFace;
					}
					
					break;
				}
				
				
				case -907766796:
				{
					if (field.equals("scoreF")) 
					{
						return this.scoreF;
					}
					
					break;
				}
				
				
				case -2099968614:
				{
					if (field.equals("diameterSquared")) 
					{
						return this.diameterSquared;
					}
					
					break;
				}
				
				
				case -907766795:
				{
					if (field.equals("scoreG")) 
					{
						return this.scoreG;
					}
					
					break;
				}
				
				
				case -233204595:
				{
					if (field.equals("diameter")) 
					{
						return this.diameter;
					}
					
					break;
				}
				
				
				case -907766794:
				{
					if (field.equals("scoreH")) 
					{
						return this.scoreH;
					}
					
					break;
				}
				
				
				case -677179915:
				{
					if (field.equals("radiusSquared")) 
					{
						return this.radiusSquared;
					}
					
					break;
				}
				
				
				case -1925032183:
				{
					if (field.equals("predecessor")) 
					{
						return this.predecessor;
					}
					
					break;
				}
				
				
				case 1181683957:
				{
					if (field.equals("iterEdge")) 
					{
						return this.iterEdge;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField(field, throwErrors, isCheck, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public double __hx_getField_f(java.lang.String field, boolean throwErrors, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case -2099968614:
				{
					if (field.equals("diameterSquared")) 
					{
						return this.diameterSquared;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case -233204595:
				{
					if (field.equals("diameter")) 
					{
						return this.diameter;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						return this._radius;
					}
					
					break;
				}
				
				
				case -677179915:
				{
					if (field.equals("radiusSquared")) 
					{
						return this.radiusSquared;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField_f(field, throwErrors, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_invokeField(java.lang.String field, haxe.root.Array dynargs)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1566142678:
				{
					if (field.equals("isWalkableByRadius")) 
					{
						return this.isWalkableByRadius(((hxDaedalus.data.Edge) (dynargs.__get(0)) ), ((hxDaedalus.data.Face) (dynargs.__get(1)) ), ((hxDaedalus.data.Edge) (dynargs.__get(2)) ));
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						__temp_executeDef1 = false;
						this.dispose();
					}
					
					break;
				}
				
				
				case 96567954:
				{
					if (field.equals("sortingFaces")) 
					{
						return this.sortingFaces(((hxDaedalus.data.Face) (dynargs.__get(0)) ), ((hxDaedalus.data.Face) (dynargs.__get(1)) ));
					}
					
					break;
				}
				
				
				case 1142099355:
				{
					if (field.equals("get_radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case -679327362:
				{
					if (field.equals("findPath")) 
					{
						__temp_executeDef1 = false;
						this.findPath(haxe.lang.Runtime.toDouble(dynargs.__get(0)), haxe.lang.Runtime.toDouble(dynargs.__get(1)), haxe.lang.Runtime.toDouble(dynargs.__get(2)), haxe.lang.Runtime.toDouble(dynargs.__get(3)), ((haxe.root.Array<hxDaedalus.data.Face>) (dynargs.__get(4)) ), ((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(5)) ));
					}
					
					break;
				}
				
				
				case -1216062705:
				{
					if (field.equals("set_radius")) 
					{
						return this.set_radius(haxe.lang.Runtime.toDouble(dynargs.__get(0)));
					}
					
					break;
				}
				
				
				case 1415348138:
				{
					if (field.equals("set_mesh")) 
					{
						return this.set_mesh(((hxDaedalus.data.Mesh) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_invokeField(field, dynargs);
			}
			
		}
		
		return null;
	}
	
	
	@Override public void __hx_getFields(haxe.root.Array<java.lang.String> baseArr)
	{
		baseArr.push("curFace");
		baseArr.push("toFace");
		baseArr.push("fromFace");
		baseArr.push("diameterSquared");
		baseArr.push("diameter");
		baseArr.push("radiusSquared");
		baseArr.push("iterEdge");
		baseArr.push("predecessor");
		baseArr.push("scoreH");
		baseArr.push("scoreG");
		baseArr.push("scoreF");
		baseArr.push("entryY");
		baseArr.push("entryX");
		baseArr.push("entryEdges");
		baseArr.push("openedFaces");
		baseArr.push("sortedOpenedFaces");
		baseArr.push("closedFaces");
		baseArr.push("_mesh");
		baseArr.push("mesh");
		baseArr.push("_radius");
		baseArr.push("radius");
		super.__hx_getFields(baseArr);
	}
	
	
}


