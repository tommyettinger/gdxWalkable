// Generated by Haxe 3.4.2
package hxDaedalus.ai;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class Funnel extends haxe.lang.HxObject
{
	public Funnel(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public Funnel()
	{
		hxDaedalus.ai.Funnel.__hx_ctor_hxDaedalus_ai_Funnel(this);
	}
	
	
	public static void __hx_ctor_hxDaedalus_ai_Funnel(hxDaedalus.ai.Funnel __hx_this)
	{
		__hx_this._currPoolPointsIndex = 0;
		__hx_this._poolPointsSize = 3000;
		__hx_this._numSamplesCircle = 16;
		__hx_this._radiusSquared = ((int) (0.0) );
		__hx_this._radius = ((int) (0.0) );
		__hx_this._poolPoints = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		{
			int _g1 = 0;
			int _g = __hx_this._poolPointsSize;
			while (( _g1 < _g ))
			{
				int i = _g1++;
				__hx_this._poolPoints.push(new hxDaedalus.data.math.Point2D(null, null));
			}
			
		}
		
	}
	
	
	
	
	public double _radius;
	
	public double _radiusSquared;
	
	public int _numSamplesCircle;
	
	public haxe.root.Array<hxDaedalus.data.math.Point2D> _sampleCircle;
	
	public double _sampleCircleDistanceSquared;
	
	public void dispose()
	{
		this._sampleCircle = null;
	}
	
	
	public int _poolPointsSize;
	
	public haxe.root.Array<hxDaedalus.data.math.Point2D> _poolPoints;
	
	public int _currPoolPointsIndex;
	
	public hxDaedalus.data.math.Point2D __point;
	
	public hxDaedalus.data.math.Point2D getPoint(java.lang.Object x, java.lang.Object y)
	{
		double __temp_y2 = ( (haxe.lang.Runtime.eq(y, null)) ? (((double) (0) )) : haxe.lang.Runtime.toDouble(y));
		double __temp_x1 = ( (haxe.lang.Runtime.eq(x, null)) ? (((double) (0) )) : haxe.lang.Runtime.toDouble(x));
		this.__point = this._poolPoints.__get(this._currPoolPointsIndex);
		this.__point.setXY(__temp_x1, __temp_y2);
		this._currPoolPointsIndex++;
		if (( this._currPoolPointsIndex == this._poolPointsSize )) 
		{
			this._poolPoints.push(new hxDaedalus.data.math.Point2D(null, null));
			this._poolPointsSize++;
		}
		
		return this.__point;
	}
	
	
	public hxDaedalus.data.math.Point2D getCopyPoint(hxDaedalus.data.math.Point2D pointToCopy)
	{
		return this.getPoint(pointToCopy.x, pointToCopy.y);
	}
	
	
	public double get_radius()
	{
		return this._radius;
	}
	
	
	public double set_radius(double value)
	{
		this._radius = java.lang.Math.max(0, value);
		this._radiusSquared = ( this._radius * this._radius );
		this._sampleCircle = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		if (( this.get_radius() == 0 )) 
		{
			return 0;
		}
		
		{
			int _g1 = 0;
			int _g = this._numSamplesCircle;
			while (( _g1 < _g ))
			{
				int i = _g1++;
				this._sampleCircle.push(new hxDaedalus.data.math.Point2D(( this._radius * java.lang.Math.cos(( ( ( -2 * java.lang.Math.PI ) * i ) / this._numSamplesCircle )) ), ( this._radius * java.lang.Math.sin(( ( ( -2 * java.lang.Math.PI ) * i ) / this._numSamplesCircle )) )));
			}
			
		}
		
		this._sampleCircleDistanceSquared = ( ( (( this._sampleCircle.__get(0).x - this._sampleCircle.__get(1).x )) * (( this._sampleCircle.__get(0).x - this._sampleCircle.__get(1).x )) ) + ( (( this._sampleCircle.__get(0).y - this._sampleCircle.__get(1).y )) * (( this._sampleCircle.__get(0).y - this._sampleCircle.__get(1).y )) ) );
		return this._radius;
	}
	
	
	public void findPath(double fromX, double fromY, double toX, double toY, haxe.root.Array<hxDaedalus.data.Face> listFaces, haxe.root.Array<hxDaedalus.data.Edge> listEdges, haxe.root.Array<java.lang.Object> resultPath)
	{
		this._currPoolPointsIndex = 0;
		if (( this._radius > 0 )) 
		{
			hxDaedalus.data.Face checkFace = listFaces.__get(0);
			double distanceSquared;
			double distance;
			hxDaedalus.data.math.Point2D p1;
			hxDaedalus.data.math.Point2D p2;
			hxDaedalus.data.math.Point2D p3;
			p1 = checkFace.get_edge().get_originVertex().get_pos();
			p2 = checkFace.get_edge().get_destinationVertex().get_pos();
			p3 = checkFace.get_edge().get_nextLeftEdge().get_destinationVertex().get_pos();
			distanceSquared = ( ( (( p1.x - fromX )) * (( p1.x - fromX )) ) + ( (( p1.y - fromY )) * (( p1.y - fromY )) ) );
			if (( distanceSquared <= this._radiusSquared )) 
			{
				distance = java.lang.Math.sqrt(distanceSquared);
				fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p1.x )) / distance )) ) + p1.x );
				fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p1.y )) / distance )) ) + p1.y );
			}
			else
			{
				distanceSquared = ( ( (( p2.x - fromX )) * (( p2.x - fromX )) ) + ( (( p2.y - fromY )) * (( p2.y - fromY )) ) );
				if (( distanceSquared <= this._radiusSquared )) 
				{
					distance = java.lang.Math.sqrt(distanceSquared);
					fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p2.x )) / distance )) ) + p2.x );
					fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p2.y )) / distance )) ) + p2.y );
				}
				else
				{
					distanceSquared = ( ( (( p3.x - fromX )) * (( p3.x - fromX )) ) + ( (( p3.y - fromY )) * (( p3.y - fromY )) ) );
					if (( distanceSquared <= this._radiusSquared )) 
					{
						distance = java.lang.Math.sqrt(distanceSquared);
						fromX = ( ( ( this._radius * 1.01 ) * (( (( fromX - p3.x )) / distance )) ) + p3.x );
						fromY = ( ( ( this._radius * 1.01 ) * (( (( fromY - p3.y )) / distance )) ) + p3.y );
					}
					
				}
				
			}
			
			checkFace = listFaces.__get(( listFaces.length - 1 ));
			p1 = checkFace.get_edge().get_originVertex().get_pos();
			p2 = checkFace.get_edge().get_destinationVertex().get_pos();
			p3 = checkFace.get_edge().get_nextLeftEdge().get_destinationVertex().get_pos();
			distanceSquared = ( ( (( p1.x - toX )) * (( p1.x - toX )) ) + ( (( p1.y - toY )) * (( p1.y - toY )) ) );
			if (( distanceSquared <= this._radiusSquared )) 
			{
				distance = java.lang.Math.sqrt(distanceSquared);
				toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p1.x )) / distance )) ) + p1.x );
				toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p1.y )) / distance )) ) + p1.y );
			}
			else
			{
				distanceSquared = ( ( (( p2.x - toX )) * (( p2.x - toX )) ) + ( (( p2.y - toY )) * (( p2.y - toY )) ) );
				if (( distanceSquared <= this._radiusSquared )) 
				{
					distance = java.lang.Math.sqrt(distanceSquared);
					toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p2.x )) / distance )) ) + p2.x );
					toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p2.y )) / distance )) ) + p2.y );
				}
				else
				{
					distanceSquared = ( ( (( p3.x - toX )) * (( p3.x - toX )) ) + ( (( p3.y - toY )) * (( p3.y - toY )) ) );
					if (( distanceSquared <= this._radiusSquared )) 
					{
						distance = java.lang.Math.sqrt(distanceSquared);
						toX = ( ( ( this._radius * 1.01 ) * (( (( toX - p3.x )) / distance )) ) + p3.x );
						toY = ( ( ( this._radius * 1.01 ) * (( (( toY - p3.y )) / distance )) ) + p3.y );
					}
					
				}
				
			}
			
		}
		
		hxDaedalus.data.math.Point2D startPoint;
		hxDaedalus.data.math.Point2D endPoint;
		startPoint = new hxDaedalus.data.math.Point2D(fromX, fromY);
		endPoint = new hxDaedalus.data.math.Point2D(toX, toY);
		if (( listFaces.length == 1 )) 
		{
			resultPath.push(startPoint.x);
			resultPath.push(startPoint.y);
			resultPath.push(endPoint.x);
			resultPath.push(endPoint.y);
			return ;
		}
		
		int i;
		int j;
		int k = 0;
		hxDaedalus.data.Edge currEdge;
		hxDaedalus.data.Vertex currVertex = null;
		int direction;
		{
			hxDaedalus.data.math.Intersection _g = hxDaedalus.data.math.Geom2D.isInFace(fromX, fromY, listFaces.__get(0));
			switch (_g.index)
			{
				case 1:
				{
					hxDaedalus.data.Edge edge = ((hxDaedalus.data.Edge) (_g.params[0]) );
					if (( listEdges.__get(0) == edge )) 
					{
						listEdges.shift();
						listFaces.shift();
					}
					
					break;
				}
				
				
				default:
				{
					break;
				}
				
			}
			
		}
		
		haxe.root.Array<hxDaedalus.data.math.Point2D> funnelLeft = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		haxe.root.Array<hxDaedalus.data.math.Point2D> funnelRight = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		funnelLeft.push(startPoint);
		funnelRight.push(startPoint);
		haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object> verticesDoneSide = new haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object>();
		haxe.root.Array<hxDaedalus.data.math.Point2D> pointsList = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object> pointSides = new haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object>();
		haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, hxDaedalus.data.math.Point2D> pointSuccessor = new haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, hxDaedalus.data.math.Point2D>();
		pointSides.set(startPoint, 0);
		currEdge = listEdges.__get(0);
		int relativPos = hxDaedalus.data.math.Geom2D.getRelativePosition2(fromX, fromY, currEdge);
		hxDaedalus.data.math.Point2D prevPoint;
		hxDaedalus.data.math.Point2D newPointA;
		hxDaedalus.data.math.Point2D newPointB;
		newPointA = this.getCopyPoint(currEdge.get_destinationVertex().get_pos());
		newPointB = this.getCopyPoint(currEdge.get_originVertex().get_pos());
		pointsList.push(newPointA);
		pointsList.push(newPointB);
		pointSuccessor.set(startPoint, newPointA);
		pointSuccessor.set(newPointA, newPointB);
		prevPoint = newPointB;
		if (( relativPos == 1 )) 
		{
			pointSides.set(newPointA, 1);
			pointSides.set(newPointB, -1);
			verticesDoneSide.set(currEdge.get_destinationVertex(), 1);
			verticesDoneSide.set(currEdge.get_originVertex(), -1);
		}
		else
		{
			if (( relativPos == -1 )) 
			{
				pointSides.set(newPointA, -1);
				pointSides.set(newPointB, 1);
				verticesDoneSide.set(currEdge.get_destinationVertex(), -1);
				verticesDoneSide.set(currEdge.get_originVertex(), 1);
			}
			
		}
		
		hxDaedalus.data.Vertex fromVertex = listEdges.__get(0).get_originVertex();
		hxDaedalus.data.Vertex fromFromVertex = listEdges.__get(0).get_destinationVertex();
		{
			int _g2 = 1;
			int _g1 = listEdges.length;
			while (( _g2 < _g1 ))
			{
				int i1 = _g2++;
				currEdge = listEdges.__get(i1);
				if (( currEdge.get_originVertex() == fromVertex )) 
				{
					currVertex = currEdge.get_destinationVertex();
				}
				else
				{
					if (( currEdge.get_destinationVertex() == fromVertex )) 
					{
						currVertex = currEdge.get_originVertex();
					}
					else
					{
						if (( currEdge.get_originVertex() == fromFromVertex )) 
						{
							currVertex = currEdge.get_destinationVertex();
							fromVertex = fromFromVertex;
						}
						else
						{
							if (( currEdge.get_destinationVertex() == fromFromVertex )) 
							{
								currVertex = currEdge.get_originVertex();
								fromVertex = fromFromVertex;
							}
							
						}
						
					}
					
				}
				
				newPointA = this.getCopyPoint(currVertex.get_pos());
				pointsList.push(newPointA);
				direction = ( - (((int) (haxe.lang.Runtime.toInt(verticesDoneSide.get(fromVertex))) )) );
				pointSides.set(newPointA, direction);
				pointSuccessor.set(prevPoint, newPointA);
				verticesDoneSide.set(currVertex, direction);
				prevPoint = newPointA;
				fromFromVertex = fromVertex;
				fromVertex = currVertex;
			}
			
		}
		
		pointSuccessor.set(prevPoint, endPoint);
		pointSides.set(endPoint, 0);
		haxe.root.Array<hxDaedalus.data.math.Point2D> pathPoints = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object> pathSides = new haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object>();
		pathPoints.push(startPoint);
		pathSides.set(startPoint, 0);
		hxDaedalus.data.math.Point2D currPos;
		{
			int _g21 = 0;
			int _g11 = pointsList.length;
			while (( _g21 < _g11 ))
			{
				int i2 = _g21++;
				currPos = pointsList.__get(i2);
				if (haxe.lang.Runtime.eq(pointSides.get(currPos), -1))
				{
					j = ( funnelLeft.length - 2 );
					while (( j >= 0 ))
					{
						direction = hxDaedalus.data.math.Geom2D.getDirection(funnelLeft.__get(j).x, funnelLeft.__get(j).y, funnelLeft.__get(( j + 1 )).x, funnelLeft.__get(( j + 1 )).y, currPos.x, currPos.y);
						if (( direction != -1 )) 
						{
							funnelLeft.shift();
							{
								int _g4 = 0;
								while (( _g4 < j))
								{
									int k1 = _g4++;
									pathPoints.push(funnelLeft.__get(0));
									pathSides.set(funnelLeft.__get(0), 1);
									funnelLeft.shift();
								}
								
							}
							
							pathPoints.push(funnelLeft.__get(0));
							pathSides.set(funnelLeft.__get(0), 1);
							funnelRight.splice(0, funnelRight.length);
							funnelRight.push(funnelLeft.__get(0));
							funnelRight.push(currPos);
							break;
						}
						
						 -- j;
					}
					
					funnelRight.push(currPos);
					j = ( funnelRight.length - 3 );
					while (( j >= 0 ))
					{
						direction = hxDaedalus.data.math.Geom2D.getDirection(funnelRight.__get(j).x, funnelRight.__get(j).y, funnelRight.__get(( j + 1 )).x, funnelRight.__get(( j + 1 )).y, currPos.x, currPos.y);
						if (( direction == -1 )) 
						{
							break;
						}
						else
						{
							funnelRight.splice(( j + 1 ), 1);
						}
						
						 -- j;
					}
					
				}
				else
				{
					j = ( funnelRight.length - 2 );
					while (( j >= 0 ))
					{
						direction = hxDaedalus.data.math.Geom2D.getDirection(funnelRight.__get(j).x, funnelRight.__get(j).y, funnelRight.__get(( j + 1 )).x, funnelRight.__get(( j + 1 )).y, currPos.x, currPos.y);
						if (( direction != 1 )) 
						{
							funnelRight.shift();
							{
								int _g41 = 0;
								while (( _g41 < j))
								{
									int k2 = _g41++;
									pathPoints.push(funnelRight.__get(0));
									pathSides.set(funnelRight.__get(0), -1);
									funnelRight.shift();
								}
								
							}
							
							pathPoints.push(funnelRight.__get(0));
							pathSides.set(funnelRight.__get(0), -1);
							funnelLeft.splice(0, funnelLeft.length);
							funnelLeft.push(funnelRight.__get(0));
							funnelLeft.push(currPos);
							break;
						}
						
						 -- j;
					}
					
					funnelLeft.push(currPos);
					j = ( funnelLeft.length - 3 );
					while (( j >= 0 ))
					{
						direction = hxDaedalus.data.math.Geom2D.getDirection(funnelLeft.__get(j).x, funnelLeft.__get(j).y, funnelLeft.__get(( j + 1 )).x, funnelLeft.__get(( j + 1 )).y, currPos.x, currPos.y);
						if (( direction == 1 )) 
						{
							break;
						}
						else
						{
							funnelLeft.splice(( j + 1 ), 1);
						}
						
						 -- j;
					}
					
				}
				
			}
			
		}
		
		boolean blocked = false;
		j = ( funnelRight.length - 2 );
		while (( j >= 0 ))
		{
			direction = hxDaedalus.data.math.Geom2D.getDirection(funnelRight.__get(j).x, funnelRight.__get(j).y, funnelRight.__get(( j + 1 )).x, funnelRight.__get(( j + 1 )).y, toX, toY);
			if (( direction != 1 )) 
			{
				funnelRight.shift();
				{
					int _g22 = 0;
					int _g12 = ( j + 1 );
					while (( _g22 < _g12 ))
					{
						int k3 = _g22++;
						pathPoints.push(funnelRight.__get(0));
						pathSides.set(funnelRight.__get(0), -1);
						funnelRight.shift();
					}
					
				}
				
				pathPoints.push(endPoint);
				pathSides.set(endPoint, 0);
				blocked = true;
				break;
			}
			
			 -- j;
		}
		
		if ( ! (blocked) ) 
		{
			j = ( funnelLeft.length - 2 );
			while (( j >= 0 ))
			{
				direction = hxDaedalus.data.math.Geom2D.getDirection(funnelLeft.__get(j).x, funnelLeft.__get(j).y, funnelLeft.__get(( j + 1 )).x, funnelLeft.__get(( j + 1 )).y, toX, toY);
				if (( direction != -1 )) 
				{
					funnelLeft.shift();
					{
						int _g23 = 0;
						int _g13 = ( j + 1 );
						while (( _g23 < _g13 ))
						{
							int k4 = _g23++;
							pathPoints.push(funnelLeft.__get(0));
							pathSides.set(funnelLeft.__get(0), 1);
							funnelLeft.shift();
						}
						
					}
					
					pathPoints.push(endPoint);
					pathSides.set(endPoint, 0);
					blocked = true;
					break;
				}
				
				 -- j;
			}
			
		}
		
		if ( ! (blocked) ) 
		{
			pathPoints.push(endPoint);
			pathSides.set(endPoint, 0);
		}
		
		haxe.root.Array<hxDaedalus.data.math.Point2D> adjustedPoints = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
		if (( this.get_radius() > 0 )) 
		{
			haxe.root.Array<hxDaedalus.data.math.Point2D> newPath = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
			if (( pathPoints.length == 2 )) 
			{
				this.adjustWithTangents(pathPoints.__get(0), false, pathPoints.__get(1), false, pointSides, pointSuccessor, newPath, adjustedPoints);
			}
			else
			{
				if (( pathPoints.length > 2 )) 
				{
					this.adjustWithTangents(pathPoints.__get(0), false, pathPoints.__get(1), true, pointSides, pointSuccessor, newPath, adjustedPoints);
					if (( pathPoints.length > 3 )) 
					{
						int _g24 = 1;
						int _g14 = ( ( pathPoints.length - 3 ) + 1 );
						while (( _g24 < _g14 ))
						{
							int i3 = _g24++;
							this.adjustWithTangents(pathPoints.__get(i3), true, pathPoints.__get(( i3 + 1 )), true, pointSides, pointSuccessor, newPath, adjustedPoints);
						}
						
					}
					
					int pathLength = pathPoints.length;
					this.adjustWithTangents(pathPoints.__get(( pathLength - 2 )), true, pathPoints.__get(( pathLength - 1 )), false, pointSides, pointSuccessor, newPath, adjustedPoints);
				}
				
			}
			
			newPath.push(endPoint);
			this.checkAdjustedPath(newPath, adjustedPoints, pointSides);
			haxe.root.Array<hxDaedalus.data.math.Point2D> smoothPoints = new haxe.root.Array<hxDaedalus.data.math.Point2D>();
			i = ( newPath.length - 2 );
			while (( i >= 1 ))
			{
				this.smoothAngle(adjustedPoints.__get(( ( i * 2 ) - 1 )), newPath.__get(i), adjustedPoints.__get(( i * 2 )), haxe.lang.Runtime.toInt(pointSides.get(newPath.__get(i))), smoothPoints);
				while (( smoothPoints.length != 0 ))
				{
					int temp = ( i * 2 );
					adjustedPoints.splice(temp, 0);
					adjustedPoints.insert(temp, ((hxDaedalus.data.math.Point2D) (smoothPoints.pop()) ));
				}
				
				 -- i;
			}
			
		}
		else
		{
			adjustedPoints = pathPoints;
		}
		
		{
			int _g25 = 0;
			int _g15 = adjustedPoints.length;
			while (( _g25 < _g15 ))
			{
				int i4 = _g25++;
				resultPath.push(adjustedPoints.__get(i4).x);
				resultPath.push(adjustedPoints.__get(i4).y);
			}
			
		}
		
	}
	
	
	public void adjustWithTangents(hxDaedalus.data.math.Point2D p1, boolean applyRadiusToP1, hxDaedalus.data.math.Point2D p2, boolean applyRadiusToP2, haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object> pointSides, haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, hxDaedalus.data.math.Point2D> pointSuccessor, haxe.root.Array<hxDaedalus.data.math.Point2D> newPath, haxe.root.Array<hxDaedalus.data.math.Point2D> adjustedPoints)
	{
		haxe.root.Array<java.lang.Object> tangentsResult = new haxe.root.Array<java.lang.Object>();
		int side1 = haxe.lang.Runtime.toInt(pointSides.get(p1));
		int side2 = haxe.lang.Runtime.toInt(pointSides.get(p2));
		hxDaedalus.data.math.Point2D pTangent1 = null;
		hxDaedalus.data.math.Point2D pTangent2 = null;
		if ((  ! (applyRadiusToP1)  &&  ! (applyRadiusToP2)  )) 
		{
			pTangent1 = p1;
			pTangent2 = p2;
		}
		else
		{
			if ( ! (applyRadiusToP1) ) 
			{
				if (hxDaedalus.data.math.Geom2D.tangentsPointToCircle(p1.x, p1.y, p2.x, p2.y, this._radius, tangentsResult)) 
				{
					if (( side2 == 1 )) 
					{
						pTangent1 = p1;
						pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
					}
					else
					{
						pTangent1 = p1;
						pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
					}
					
				}
				else
				{
					return ;
				}
				
			}
			else
			{
				if ( ! (applyRadiusToP2) ) 
				{
					if (hxDaedalus.data.math.Geom2D.tangentsPointToCircle(p2.x, p2.y, p1.x, p1.y, this._radius, tangentsResult)) 
					{
						if (( tangentsResult.length > 0 )) 
						{
							if (( side1 == 1 )) 
							{
								pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
								pTangent2 = p2;
							}
							else
							{
								pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
								pTangent2 = p2;
							}
							
						}
						
					}
					else
					{
						return ;
					}
					
				}
				else
				{
					if (( ( side1 == 1 ) && ( side2 == 1 ) )) 
					{
						hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);
						pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
						pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(4)), haxe.lang.Runtime.toDouble(tangentsResult.__get(5)));
					}
					else
					{
						if (( ( side1 == -1 ) && ( side2 == -1 ) )) 
						{
							hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult);
							pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
							pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(6)), haxe.lang.Runtime.toDouble(tangentsResult.__get(7)));
						}
						else
						{
							if (( ( side1 == 1 ) && ( side2 == -1 ) )) 
							{
								if (hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) 
								{
									pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
									pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(6)), haxe.lang.Runtime.toDouble(tangentsResult.__get(7)));
								}
								else
								{
									return ;
								}
								
							}
							else
							{
								if (hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, p1.x, p1.y, p2.x, p2.y, tangentsResult)) 
								{
									pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
									pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(4)), haxe.lang.Runtime.toDouble(tangentsResult.__get(5)));
								}
								else
								{
									return ;
								}
								
							}
							
						}
						
					}
					
				}
				
			}
			
		}
		
		hxDaedalus.data.math.Point2D successor = ((hxDaedalus.data.math.Point2D) (pointSuccessor.get(p1)) );
		double distance;
		while (( successor != p2 ))
		{
			distance = hxDaedalus.data.math.Geom2D.distanceSquaredPointToSegment(successor.x, successor.y, pTangent1.x, pTangent1.y, pTangent2.x, pTangent2.y);
			if (( distance < this._radiusSquared )) 
			{
				this.adjustWithTangents(p1, applyRadiusToP1, successor, true, pointSides, pointSuccessor, newPath, adjustedPoints);
				this.adjustWithTangents(successor, true, p2, applyRadiusToP2, pointSides, pointSuccessor, newPath, adjustedPoints);
				return ;
			}
			else
			{
				successor = ((hxDaedalus.data.math.Point2D) (pointSuccessor.get(successor)) );
			}
			
		}
		
		adjustedPoints.push(pTangent1);
		adjustedPoints.push(pTangent2);
		newPath.push(p1);
	}
	
	
	public void checkAdjustedPath(haxe.root.Array<hxDaedalus.data.math.Point2D> newPath, haxe.root.Array<hxDaedalus.data.math.Point2D> adjustedPoints, haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object> pointSides)
	{
		boolean needCheck = true;
		hxDaedalus.data.math.Point2D point0;
		int point0Side;
		hxDaedalus.data.math.Point2D point1;
		int point1Side;
		hxDaedalus.data.math.Point2D point2;
		int point2Side;
		hxDaedalus.data.math.Point2D pt1;
		hxDaedalus.data.math.Point2D pt2;
		hxDaedalus.data.math.Point2D pt3;
		double dot;
		haxe.root.Array<java.lang.Object> tangentsResult = new haxe.root.Array<java.lang.Object>();
		hxDaedalus.data.math.Point2D pTangent1 = null;
		hxDaedalus.data.math.Point2D pTangent2 = null;
		while (needCheck)
		{
			needCheck = false;
			int i = 2;
			while (( i < newPath.length ))
			{
				point2 = newPath.__get(i);
				point2Side = haxe.lang.Runtime.toInt(pointSides.get(point2));
				point1 = newPath.__get(( i - 1 ));
				point1Side = haxe.lang.Runtime.toInt(pointSides.get(point1));
				point0 = newPath.__get(( i - 2 ));
				point0Side = haxe.lang.Runtime.toInt(pointSides.get(point0));
				if (( point1Side == point2Side )) 
				{
					pt1 = adjustedPoints.__get(( (( i - 2 )) * 2 ));
					pt2 = adjustedPoints.__get(( ( (( i - 1 )) * 2 ) - 1 ));
					pt3 = adjustedPoints.__get(( (( i - 1 )) * 2 ));
					dot = ( ( (( pt1.x - pt2.x )) * (( pt3.x - pt2.x )) ) + ( (( pt1.y - pt2.y )) * (( pt3.y - pt2.y )) ) );
					if (( dot > 0 )) 
					{
						if (( i == 2 )) 
						{
							hxDaedalus.data.math.Geom2D.tangentsPointToCircle(point0.x, point0.y, point2.x, point2.y, this._radius, tangentsResult);
							if (( point2Side == 1 )) 
							{
								pTangent1 = point0;
								pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
							}
							else
							{
								pTangent1 = point0;
								pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
							}
							
						}
						else
						{
							if (( i == ( newPath.length - 1 ) )) 
							{
								hxDaedalus.data.math.Geom2D.tangentsPointToCircle(point2.x, point2.y, point0.x, point0.y, this._radius, tangentsResult);
								if (( point0Side == 1 )) 
								{
									pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
									pTangent2 = point2;
								}
								else
								{
									pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
									pTangent2 = point2;
								}
								
							}
							else
							{
								if (( ( point0Side == 1 ) && ( point2Side == -1 ) )) 
								{
									hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
									pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
									pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(6)), haxe.lang.Runtime.toDouble(tangentsResult.__get(7)));
								}
								else
								{
									if (( ( point0Side == -1 ) && ( point2Side == 1 ) )) 
									{
										hxDaedalus.data.math.Geom2D.tangentsCrossCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
										pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
										pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(4)), haxe.lang.Runtime.toDouble(tangentsResult.__get(5)));
									}
									else
									{
										if (( ( point0Side == 1 ) && ( point2Side == 1 ) )) 
										{
											hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
											pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(2)), haxe.lang.Runtime.toDouble(tangentsResult.__get(3)));
											pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(4)), haxe.lang.Runtime.toDouble(tangentsResult.__get(5)));
										}
										else
										{
											if (( ( point0Side == -1 ) && ( point2Side == -1 ) )) 
											{
												hxDaedalus.data.math.Geom2D.tangentsParalCircleToCircle(this._radius, point0.x, point0.y, point2.x, point2.y, tangentsResult);
												pTangent1 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(0)), haxe.lang.Runtime.toDouble(tangentsResult.__get(1)));
												pTangent2 = this.getPoint(haxe.lang.Runtime.toDouble(tangentsResult.__get(6)), haxe.lang.Runtime.toDouble(tangentsResult.__get(7)));
											}
											
										}
										
									}
									
								}
								
							}
							
						}
						
						int temp = ( (( i - 2 )) * 2 );
						adjustedPoints.splice(temp, 1);
						adjustedPoints.insert(temp, pTangent1);
						temp = ( ( i * 2 ) - 1 );
						adjustedPoints.splice(temp, 1);
						adjustedPoints.insert(temp, pTangent2);
						newPath.splice(( i - 1 ), 1);
						adjustedPoints.splice(( ( (( i - 1 )) * 2 ) - 1 ), 2);
						tangentsResult.splice(0, tangentsResult.length);
						 -- i;
					}
					
				}
				
				 ++ i;
			}
			
		}
		
	}
	
	
	public void smoothAngle(hxDaedalus.data.math.Point2D prevPoint, hxDaedalus.data.math.Point2D pointToSmooth, hxDaedalus.data.math.Point2D nextPoint, int side, haxe.root.Array<hxDaedalus.data.math.Point2D> encirclePoints)
	{
		int angleType = hxDaedalus.data.math.Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y);
		double distanceSquared = ( ( (( prevPoint.x - nextPoint.x )) * (( prevPoint.x - nextPoint.x )) ) + ( (( prevPoint.y - nextPoint.y )) * (( prevPoint.y - nextPoint.y )) ) );
		if (( distanceSquared <= this._sampleCircleDistanceSquared )) 
		{
			return ;
		}
		
		int index = 0;
		int side1;
		int side2;
		boolean pointInArea;
		double xToCheck;
		double yToCheck;
		{
			int _g1 = 0;
			int _g = this._numSamplesCircle;
			while (( _g1 < _g ))
			{
				int i = _g1++;
				pointInArea = false;
				xToCheck = ( pointToSmooth.x + this._sampleCircle.__get(i).x );
				yToCheck = ( pointToSmooth.y + this._sampleCircle.__get(i).y );
				side1 = hxDaedalus.data.math.Geom2D.getDirection(prevPoint.x, prevPoint.y, pointToSmooth.x, pointToSmooth.y, xToCheck, yToCheck);
				side2 = hxDaedalus.data.math.Geom2D.getDirection(pointToSmooth.x, pointToSmooth.y, nextPoint.x, nextPoint.y, xToCheck, yToCheck);
				if (( side == 1 )) 
				{
					if (( angleType == -1 )) 
					{
						if (( ( side1 == -1 ) && ( side2 == -1 ) )) 
						{
							pointInArea = true;
						}
						
					}
					else
					{
						if (( ( side1 == -1 ) || ( side2 == -1 ) )) 
						{
							pointInArea = true;
						}
						
					}
					
				}
				else
				{
					if (( angleType == 1 )) 
					{
						if (( ( side1 == 1 ) && ( side2 == 1 ) )) 
						{
							pointInArea = true;
						}
						
					}
					else
					{
						if (( ( side1 == 1 ) || ( side2 == 1 ) )) 
						{
							pointInArea = true;
						}
						
					}
					
				}
				
				if (pointInArea) 
				{
					encirclePoints.splice(index, 0);
					encirclePoints.insert(index, new hxDaedalus.data.math.Point2D(xToCheck, yToCheck));
					 ++ index;
				}
				else
				{
					index = 0;
				}
				
			}
			
		}
		
		if (( side == -1 )) 
		{
			encirclePoints.reverse();
		}
		
	}
	
	
	@Override public double __hx_setField_f(java.lang.String field, double value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 127970466:
				{
					if (field.equals("_currPoolPointsIndex")) 
					{
						this._currPoolPointsIndex = ((int) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						this.set_radius(value);
						return value;
					}
					
					break;
				}
				
				
				case 2115827423:
				{
					if (field.equals("_poolPointsSize")) 
					{
						this._poolPointsSize = ((int) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						this._radius = value;
						return value;
					}
					
					break;
				}
				
				
				case 1835192057:
				{
					if (field.equals("_sampleCircleDistanceSquared")) 
					{
						this._sampleCircleDistanceSquared = value;
						return value;
					}
					
					break;
				}
				
				
				case -1460609034:
				{
					if (field.equals("_radiusSquared")) 
					{
						this._radiusSquared = value;
						return value;
					}
					
					break;
				}
				
				
				case 1630359218:
				{
					if (field.equals("_numSamplesCircle")) 
					{
						this._numSamplesCircle = ((int) (value) );
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField_f(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_setField(java.lang.String field, java.lang.Object value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1240118704:
				{
					if (field.equals("__point")) 
					{
						this.__point = ((hxDaedalus.data.math.Point2D) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						this.set_radius(haxe.lang.Runtime.toDouble(value));
						return value;
					}
					
					break;
				}
				
				
				case 127970466:
				{
					if (field.equals("_currPoolPointsIndex")) 
					{
						this._currPoolPointsIndex = haxe.lang.Runtime.toInt(value);
						return value;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						this._radius = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 1430303166:
				{
					if (field.equals("_poolPoints")) 
					{
						this._poolPoints = ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1460609034:
				{
					if (field.equals("_radiusSquared")) 
					{
						this._radiusSquared = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 2115827423:
				{
					if (field.equals("_poolPointsSize")) 
					{
						this._poolPointsSize = haxe.lang.Runtime.toInt(value);
						return value;
					}
					
					break;
				}
				
				
				case 1630359218:
				{
					if (field.equals("_numSamplesCircle")) 
					{
						this._numSamplesCircle = haxe.lang.Runtime.toInt(value);
						return value;
					}
					
					break;
				}
				
				
				case 1835192057:
				{
					if (field.equals("_sampleCircleDistanceSquared")) 
					{
						this._sampleCircleDistanceSquared = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 1836065017:
				{
					if (field.equals("_sampleCircle")) 
					{
						this._sampleCircle = ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (value) );
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_getField(java.lang.String field, boolean throwErrors, boolean isCheck, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case -404590651:
				{
					if (field.equals("smoothAngle")) 
					{
						return new haxe.lang.Closure(this, "smoothAngle");
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case -1381532965:
				{
					if (field.equals("checkAdjustedPath")) 
					{
						return new haxe.lang.Closure(this, "checkAdjustedPath");
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						return this._radius;
					}
					
					break;
				}
				
				
				case 2118091491:
				{
					if (field.equals("adjustWithTangents")) 
					{
						return new haxe.lang.Closure(this, "adjustWithTangents");
					}
					
					break;
				}
				
				
				case -1460609034:
				{
					if (field.equals("_radiusSquared")) 
					{
						return this._radiusSquared;
					}
					
					break;
				}
				
				
				case -679327362:
				{
					if (field.equals("findPath")) 
					{
						return new haxe.lang.Closure(this, "findPath");
					}
					
					break;
				}
				
				
				case 1630359218:
				{
					if (field.equals("_numSamplesCircle")) 
					{
						return this._numSamplesCircle;
					}
					
					break;
				}
				
				
				case -1216062705:
				{
					if (field.equals("set_radius")) 
					{
						return new haxe.lang.Closure(this, "set_radius");
					}
					
					break;
				}
				
				
				case 1836065017:
				{
					if (field.equals("_sampleCircle")) 
					{
						return this._sampleCircle;
					}
					
					break;
				}
				
				
				case 1142099355:
				{
					if (field.equals("get_radius")) 
					{
						return new haxe.lang.Closure(this, "get_radius");
					}
					
					break;
				}
				
				
				case 1835192057:
				{
					if (field.equals("_sampleCircleDistanceSquared")) 
					{
						return this._sampleCircleDistanceSquared;
					}
					
					break;
				}
				
				
				case 1482066021:
				{
					if (field.equals("getCopyPoint")) 
					{
						return new haxe.lang.Closure(this, "getCopyPoint");
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						return new haxe.lang.Closure(this, "dispose");
					}
					
					break;
				}
				
				
				case 1962671066:
				{
					if (field.equals("getPoint")) 
					{
						return new haxe.lang.Closure(this, "getPoint");
					}
					
					break;
				}
				
				
				case 2115827423:
				{
					if (field.equals("_poolPointsSize")) 
					{
						return this._poolPointsSize;
					}
					
					break;
				}
				
				
				case 1240118704:
				{
					if (field.equals("__point")) 
					{
						return this.__point;
					}
					
					break;
				}
				
				
				case 1430303166:
				{
					if (field.equals("_poolPoints")) 
					{
						return this._poolPoints;
					}
					
					break;
				}
				
				
				case 127970466:
				{
					if (field.equals("_currPoolPointsIndex")) 
					{
						return this._currPoolPointsIndex;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField(field, throwErrors, isCheck, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public double __hx_getField_f(java.lang.String field, boolean throwErrors, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 127970466:
				{
					if (field.equals("_currPoolPointsIndex")) 
					{
						return this._currPoolPointsIndex;
					}
					
					break;
				}
				
				
				case -938578798:
				{
					if (field.equals("radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case 2115827423:
				{
					if (field.equals("_poolPointsSize")) 
					{
						return this._poolPointsSize;
					}
					
					break;
				}
				
				
				case 1769892273:
				{
					if (field.equals("_radius")) 
					{
						return this._radius;
					}
					
					break;
				}
				
				
				case 1835192057:
				{
					if (field.equals("_sampleCircleDistanceSquared")) 
					{
						return this._sampleCircleDistanceSquared;
					}
					
					break;
				}
				
				
				case -1460609034:
				{
					if (field.equals("_radiusSquared")) 
					{
						return this._radiusSquared;
					}
					
					break;
				}
				
				
				case 1630359218:
				{
					if (field.equals("_numSamplesCircle")) 
					{
						return this._numSamplesCircle;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField_f(field, throwErrors, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_invokeField(java.lang.String field, haxe.root.Array dynargs)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case -404590651:
				{
					if (field.equals("smoothAngle")) 
					{
						__temp_executeDef1 = false;
						this.smoothAngle(((hxDaedalus.data.math.Point2D) (dynargs.__get(0)) ), ((hxDaedalus.data.math.Point2D) (dynargs.__get(1)) ), ((hxDaedalus.data.math.Point2D) (dynargs.__get(2)) ), haxe.lang.Runtime.toInt(dynargs.__get(3)), ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (dynargs.__get(4)) ));
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						__temp_executeDef1 = false;
						this.dispose();
					}
					
					break;
				}
				
				
				case -1381532965:
				{
					if (field.equals("checkAdjustedPath")) 
					{
						__temp_executeDef1 = false;
						this.checkAdjustedPath(((haxe.root.Array<hxDaedalus.data.math.Point2D>) (dynargs.__get(0)) ), ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (dynargs.__get(1)) ), ((haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object>) (dynargs.__get(2)) ));
					}
					
					break;
				}
				
				
				case 1962671066:
				{
					if (field.equals("getPoint")) 
					{
						return this.getPoint(dynargs.__get(0), dynargs.__get(1));
					}
					
					break;
				}
				
				
				case 2118091491:
				{
					if (field.equals("adjustWithTangents")) 
					{
						__temp_executeDef1 = false;
						this.adjustWithTangents(((hxDaedalus.data.math.Point2D) (dynargs.__get(0)) ), haxe.lang.Runtime.toBool(dynargs.__get(1)), ((hxDaedalus.data.math.Point2D) (dynargs.__get(2)) ), haxe.lang.Runtime.toBool(dynargs.__get(3)), ((haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, java.lang.Object>) (dynargs.__get(4)) ), ((haxe.ds.ObjectMap<hxDaedalus.data.math.Point2D, hxDaedalus.data.math.Point2D>) (dynargs.__get(5)) ), ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (dynargs.__get(6)) ), ((haxe.root.Array<hxDaedalus.data.math.Point2D>) (dynargs.__get(7)) ));
					}
					
					break;
				}
				
				
				case 1482066021:
				{
					if (field.equals("getCopyPoint")) 
					{
						return this.getCopyPoint(((hxDaedalus.data.math.Point2D) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case -679327362:
				{
					if (field.equals("findPath")) 
					{
						__temp_executeDef1 = false;
						this.findPath(haxe.lang.Runtime.toDouble(dynargs.__get(0)), haxe.lang.Runtime.toDouble(dynargs.__get(1)), haxe.lang.Runtime.toDouble(dynargs.__get(2)), haxe.lang.Runtime.toDouble(dynargs.__get(3)), ((haxe.root.Array<hxDaedalus.data.Face>) (dynargs.__get(4)) ), ((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(5)) ), ((haxe.root.Array<java.lang.Object>) (dynargs.__get(6)) ));
					}
					
					break;
				}
				
				
				case 1142099355:
				{
					if (field.equals("get_radius")) 
					{
						return this.get_radius();
					}
					
					break;
				}
				
				
				case -1216062705:
				{
					if (field.equals("set_radius")) 
					{
						return this.set_radius(haxe.lang.Runtime.toDouble(dynargs.__get(0)));
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_invokeField(field, dynargs);
			}
			
		}
		
		return null;
	}
	
	
	@Override public void __hx_getFields(haxe.root.Array<java.lang.String> baseArr)
	{
		baseArr.push("__point");
		baseArr.push("_currPoolPointsIndex");
		baseArr.push("_poolPoints");
		baseArr.push("_poolPointsSize");
		baseArr.push("_sampleCircleDistanceSquared");
		baseArr.push("_sampleCircle");
		baseArr.push("_numSamplesCircle");
		baseArr.push("_radiusSquared");
		baseArr.push("_radius");
		baseArr.push("radius");
		super.__hx_getFields(baseArr);
	}
	
	
}


