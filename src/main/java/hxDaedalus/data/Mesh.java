// Generated by Haxe 3.4.2
package hxDaedalus.data;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class Mesh extends haxe.lang.HxObject
{
	static
	{
		hxDaedalus.data.Mesh.INC = 0;
	}
	
	public Mesh(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public Mesh(double width, double height)
	{
		hxDaedalus.data.Mesh.__hx_ctor_hxDaedalus_data_Mesh(this, width, height);
	}
	
	
	public static void __hx_ctor_hxDaedalus_data_Mesh(hxDaedalus.data.Mesh __hx_this, double width, double height)
	{
		__hx_this.__objectsUpdateInProgress = false;
		__hx_this.__edgesToCheck = null;
		__hx_this.__centerVertex = null;
		__hx_this._objects = null;
		__hx_this._constraintShapes = null;
		__hx_this._faces = null;
		__hx_this._edges = null;
		__hx_this._vertices = null;
		__hx_this._id = hxDaedalus.data.Mesh.INC;
		hxDaedalus.data.Mesh.INC++;
		__hx_this._width = width;
		__hx_this._height = height;
		__hx_this._clipping = true;
		__hx_this._vertices = new haxe.root.Array<hxDaedalus.data.Vertex>();
		__hx_this._edges = new haxe.root.Array<hxDaedalus.data.Edge>();
		__hx_this._faces = new haxe.root.Array<hxDaedalus.data.Face>();
		__hx_this._constraintShapes = new haxe.root.Array<hxDaedalus.data.ConstraintShape>();
		__hx_this._objects = new haxe.root.Array<hxDaedalus.data.Obstacle>();
		__hx_this.__edgesToCheck = new haxe.root.Array<hxDaedalus.data.Edge>();
	}
	
	
	public static int INC;
	
	
	
	
	
	
	
	
	
	
	
	public int _id;
	
	public double _width;
	
	public double _height;
	
	public boolean _clipping;
	
	public haxe.root.Array<hxDaedalus.data.Vertex> _vertices;
	
	public haxe.root.Array<hxDaedalus.data.Edge> _edges;
	
	public haxe.root.Array<hxDaedalus.data.Face> _faces;
	
	public haxe.root.Array<hxDaedalus.data.ConstraintShape> _constraintShapes;
	
	public haxe.root.Array<hxDaedalus.data.Obstacle> _objects;
	
	public hxDaedalus.data.Vertex __centerVertex;
	
	public haxe.root.Array<hxDaedalus.data.Edge> __edgesToCheck;
	
	public double get_height()
	{
		return this._height;
	}
	
	
	public double get_width()
	{
		return this._width;
	}
	
	
	public boolean get_clipping()
	{
		return this._clipping;
	}
	
	
	public boolean set_clipping(boolean value)
	{
		this._clipping = value;
		return value;
	}
	
	
	public int get_id()
	{
		return this._id;
	}
	
	
	public void dispose()
	{
		while (( this._vertices.length > 0 ))
		{
			((hxDaedalus.data.Vertex) (this._vertices.pop()) ).dispose();
		}
		
		this._vertices = null;
		while (( this._edges.length > 0 ))
		{
			((hxDaedalus.data.Edge) (this._edges.pop()) ).dispose();
		}
		
		this._edges = null;
		while (( this._faces.length > 0 ))
		{
			((hxDaedalus.data.Face) (this._faces.pop()) ).dispose();
		}
		
		this._faces = null;
		while (( this._constraintShapes.length > 0 ))
		{
			((hxDaedalus.data.ConstraintShape) (this._constraintShapes.pop()) ).dispose();
		}
		
		this._constraintShapes = null;
		while (( this._objects.length > 0 ))
		{
			((hxDaedalus.data.Obstacle) (this._objects.pop()) ).dispose();
		}
		
		this._objects = null;
		this.__edgesToCheck = null;
		this.__centerVertex = null;
	}
	
	
	public haxe.root.Array<hxDaedalus.data.ConstraintShape> get___constraintShapes()
	{
		return this._constraintShapes;
	}
	
	
	public void buildFromRecord(java.lang.String rec)
	{
		haxe.root.Array<java.lang.String> positions = haxe.lang.StringExt.split(rec, ";");
		int i = 0;
		while (( i < positions.length ))
		{
			this.insertConstraintSegment(haxe.root.Std.parseFloat(positions.__get(i)), haxe.root.Std.parseFloat(positions.__get(( i + 1 ))), haxe.root.Std.parseFloat(positions.__get(( i + 2 ))), haxe.root.Std.parseFloat(positions.__get(( i + 3 ))));
			i += 4;
		}
		
	}
	
	
	public void insertObject(hxDaedalus.data.Obstacle object)
	{
		if (( object.get_constraintShape() != null )) 
		{
			this.deleteObject(object);
		}
		
		hxDaedalus.data.ConstraintShape shape = new hxDaedalus.data.ConstraintShape();
		hxDaedalus.data.ConstraintSegment segment;
		haxe.root.Array<java.lang.Object> coordinates = object.get_coordinates();
		hxDaedalus.data.math.Matrix2D m = object.get_matrix();
		object.updateMatrixFromValues();
		double x1;
		double y1;
		double x2;
		double y2;
		double transfx1;
		double transfy1;
		double transfx2;
		double transfy2;
		int i = 0;
		while (( i < coordinates.length ))
		{
			x1 = haxe.lang.Runtime.toDouble(coordinates.__get(i));
			y1 = haxe.lang.Runtime.toDouble(coordinates.__get(( i + 1 )));
			x2 = haxe.lang.Runtime.toDouble(coordinates.__get(( i + 2 )));
			y2 = haxe.lang.Runtime.toDouble(coordinates.__get(( i + 3 )));
			transfx1 = m.transformX(x1, y1);
			transfy1 = m.transformY(x1, y1);
			transfx2 = m.transformX(x2, y2);
			transfy2 = m.transformY(x2, y2);
			segment = this.insertConstraintSegment(transfx1, transfy1, transfx2, transfy2);
			if (( segment != null )) 
			{
				segment.fromShape = shape;
				shape.segments.push(segment);
			}
			
			i += 4;
		}
		
		this._constraintShapes.push(shape);
		object.set_constraintShape(shape);
		if ( ! (this.__objectsUpdateInProgress) ) 
		{
			this._objects.push(object);
		}
		
	}
	
	
	public void deleteObject(hxDaedalus.data.Obstacle object)
	{
		if (( object.get_constraintShape() == null )) 
		{
			return ;
		}
		
		this.deleteConstraintShape(object.get_constraintShape());
		object.set_constraintShape(null);
		if ( ! (this.__objectsUpdateInProgress) ) 
		{
			int index = this._objects.indexOf(object, null);
			this._objects.splice(index, 1);
		}
		
	}
	
	
	public boolean __objectsUpdateInProgress;
	
	public void updateObjects()
	{
		this.__objectsUpdateInProgress = true;
		{
			int _g1 = 0;
			int _g = this._objects.length;
			while (( _g1 < _g ))
			{
				int i = _g1++;
				if (this._objects.__get(i).get_hasChanged()) 
				{
					this.deleteObject(this._objects.__get(i));
					this.insertObject(this._objects.__get(i));
					this._objects.__get(i).set_hasChanged(false);
				}
				
			}
			
		}
		
		this.__objectsUpdateInProgress = false;
	}
	
	
	public hxDaedalus.data.ConstraintShape insertConstraintShape(haxe.root.Array<java.lang.Object> coordinates)
	{
		hxDaedalus.data.ConstraintShape shape = new hxDaedalus.data.ConstraintShape();
		hxDaedalus.data.ConstraintSegment segment;
		int i = 0;
		while (( i < coordinates.length ))
		{
			segment = this.insertConstraintSegment(haxe.lang.Runtime.toDouble(coordinates.__get(i)), haxe.lang.Runtime.toDouble(coordinates.__get(( i + 1 ))), haxe.lang.Runtime.toDouble(coordinates.__get(( i + 2 ))), haxe.lang.Runtime.toDouble(coordinates.__get(( i + 3 ))));
			if (( segment != null )) 
			{
				segment.fromShape = shape;
				shape.segments.push(segment);
			}
			
			i += 4;
		}
		
		this._constraintShapes.push(shape);
		return shape;
	}
	
	
	public void deleteConstraintShape(hxDaedalus.data.ConstraintShape shape)
	{
		{
			int _g1 = 0;
			int _g = shape.segments.length;
			while (( _g1 < _g ))
			{
				int i = _g1++;
				this.deleteConstraintSegment(shape.segments.__get(i));
			}
			
		}
		
		shape.dispose();
		this._constraintShapes.splice(this._constraintShapes.indexOf(shape, null), 1);
	}
	
	
	public hxDaedalus.data.ConstraintSegment insertConstraintSegment(double x1, double y1, double x2, double y2)
	{
		int p1pos = this.findPositionFromBounds(x1, y1);
		int p2pos = this.findPositionFromBounds(x2, y2);
		double newX1 = x1;
		double newY1 = y1;
		double newX2 = x2;
		double newY2 = y2;
		if (( this._clipping && (( ( p1pos != 0 ) || ( p2pos != 0 ) )) )) 
		{
			hxDaedalus.data.math.Point2D intersectPoint = new hxDaedalus.data.math.Point2D(null, null);
			if (( ( p1pos != 0 ) && ( p2pos != 0 ) )) 
			{
				if (( ( ( ( ( x1 <= 0 ) && ( x2 <= 0 ) ) || ( ( x1 >= this._width ) && ( x2 >= this._width ) ) ) || ( ( y1 <= 0 ) && ( y2 <= 0 ) ) ) || ( ( y1 >= this._height ) && ( y2 >= this._height ) ) )) 
				{
					return null;
				}
				
				if (( ( ( p1pos == 8 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 8 ) ) )) 
				{
					hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null);
					newX1 = intersectPoint.x;
					newY1 = intersectPoint.y;
					hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null);
					newX2 = intersectPoint.x;
					newY2 = intersectPoint.y;
				}
				else
				{
					if (( ( ( p1pos == 2 ) && ( p2pos == 6 ) ) || ( ( p1pos == 6 ) && ( p2pos == 2 ) ) )) 
					{
						hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null);
						newX1 = intersectPoint.x;
						newY1 = intersectPoint.y;
						hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null);
						newX2 = intersectPoint.x;
						newY2 = intersectPoint.y;
					}
					else
					{
						if (( ( ( p1pos == 2 ) && ( p2pos == 8 ) ) || ( ( p1pos == 8 ) && ( p2pos == 2 ) ) )) 
						{
							if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null))
							{
								newX1 = intersectPoint.x;
								newY1 = intersectPoint.y;
								hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null);
								newX2 = intersectPoint.x;
								newY2 = intersectPoint.y;
							}
							else
							{
								return null;
							}
							
						}
						else
						{
							if (( ( ( p1pos == 2 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 2 ) ) )) 
							{
								if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null))
								{
									newX1 = intersectPoint.x;
									newY1 = intersectPoint.y;
									hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null);
									newX2 = intersectPoint.x;
									newY2 = intersectPoint.y;
								}
								else
								{
									return null;
								}
								
							}
							else
							{
								if (( ( ( p1pos == 6 ) && ( p2pos == 4 ) ) || ( ( p1pos == 4 ) && ( p2pos == 6 ) ) )) 
								{
									if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null))
									{
										newX1 = intersectPoint.x;
										newY1 = intersectPoint.y;
										hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null);
										newX2 = intersectPoint.x;
										newY2 = intersectPoint.y;
									}
									else
									{
										return null;
									}
									
								}
								else
								{
									if (( ( ( p1pos == 8 ) && ( p2pos == 6 ) ) || ( ( p1pos == 6 ) && ( p2pos == 8 ) ) )) 
									{
										if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null))
										{
											newX1 = intersectPoint.x;
											newY1 = intersectPoint.y;
											hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null);
											newX2 = intersectPoint.x;
											newY2 = intersectPoint.y;
										}
										else
										{
											return null;
										}
										
									}
									else
									{
										boolean firstDone = false;
										boolean secondDone = false;
										if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null))
										{
											newX1 = intersectPoint.x;
											newY1 = intersectPoint.y;
											firstDone = true;
										}
										
										if (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null))
										{
											if ( ! (firstDone) ) 
											{
												newX1 = intersectPoint.x;
												newY1 = intersectPoint.y;
												firstDone = true;
											}
											else
											{
												newX2 = intersectPoint.x;
												newY2 = intersectPoint.y;
												secondDone = true;
											}
											
										}
										
										if ((  ! (secondDone)  && hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null) ))
										{
											if ( ! (firstDone) ) 
											{
												newX1 = intersectPoint.x;
												newY1 = intersectPoint.y;
												firstDone = true;
											}
											else
											{
												newX2 = intersectPoint.x;
												newY2 = intersectPoint.y;
												secondDone = true;
											}
											
										}
										
										if ((  ! (secondDone)  && hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null) ))
										{
											newX2 = intersectPoint.x;
											newY2 = intersectPoint.y;
										}
										
										if ( ! (firstDone) ) 
										{
											return null;
										}
										
									}
									
								}
								
							}
							
						}
						
					}
					
				}
				
			}
			else
			{
				if (( ( p1pos == 2 ) || ( p2pos == 2 ) )) 
				{
					hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null);
				}
				else
				{
					if (( ( p1pos == 4 ) || ( p2pos == 4 ) )) 
					{
						hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null);
					}
					else
					{
						if (( ( p1pos == 6 ) || ( p2pos == 6 ) )) 
						{
							hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null);
						}
						else
						{
							if (( ( p1pos == 8 ) || ( p2pos == 8 ) )) 
							{
								hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null);
							}
							else
							{
								if ( ! (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, this._width, 0, intersectPoint, null, null)) )
								{
									if ( ! (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, this._width, 0, this._width, this._height, intersectPoint, null, null)) )
									{
										if ( ! (hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, this._height, this._width, this._height, intersectPoint, null, null)) )
										{
											hxDaedalus.data.math.Geom2D.intersections2segments(x1, y1, x2, y2, 0, 0, 0, this._height, intersectPoint, null, null);
										}
										
									}
									
								}
								
							}
							
						}
						
					}
					
				}
				
				if (( p1pos == 0 )) 
				{
					newX1 = x1;
					newY1 = y1;
				}
				else
				{
					newX1 = x2;
					newY1 = y2;
				}
				
				newX2 = intersectPoint.x;
				newY2 = intersectPoint.y;
			}
			
		}
		
		hxDaedalus.data.Vertex vertexDown = this.insertVertex(newX1, newY1);
		if (( vertexDown == null )) 
		{
			return null;
		}
		
		hxDaedalus.data.Vertex vertexUp = this.insertVertex(newX2, newY2);
		if (( vertexUp == null )) 
		{
			return null;
		}
		
		if (( vertexDown == vertexUp )) 
		{
			return null;
		}
		
		hxDaedalus.iterators.FromVertexToOutgoingEdges iterVertexToOutEdges = new hxDaedalus.iterators.FromVertexToOutgoingEdges();
		hxDaedalus.data.Vertex currVertex;
		hxDaedalus.data.Edge currEdge;
		int i = 0;
		hxDaedalus.data.ConstraintSegment segment = new hxDaedalus.data.ConstraintSegment();
		hxDaedalus.data.Edge tempEdgeDownUp = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge tempSdgeUpDown = new hxDaedalus.data.Edge();
		tempEdgeDownUp.setDatas(vertexDown, tempSdgeUpDown, null, null, true, true);
		tempSdgeUpDown.setDatas(vertexUp, tempEdgeDownUp, null, null, true, true);
		haxe.root.Array<hxDaedalus.data.Edge> intersectedEdges = new haxe.root.Array<hxDaedalus.data.Edge>();
		haxe.root.Array<hxDaedalus.data.Edge> leftBoundingEdges = new haxe.root.Array<hxDaedalus.data.Edge>();
		haxe.root.Array<hxDaedalus.data.Edge> rightBoundingEdges = new haxe.root.Array<hxDaedalus.data.Edge>();
		hxDaedalus.data.math.Intersection currObjet;
		hxDaedalus.data.math.Point2D pIntersect = new hxDaedalus.data.math.Point2D(null, null);
		hxDaedalus.data.Edge edgeLeft;
		hxDaedalus.data.Edge newEdgeDownUp;
		hxDaedalus.data.Edge newEdgeUpDown;
		boolean done;
		currVertex = vertexDown;
		currObjet = hxDaedalus.data.math.Intersection.EVertex(currVertex);
		while (true)
		{
			done = false;
			switch (currObjet.index)
			{
				case 0:
				{
					hxDaedalus.data.Vertex vertex = ((hxDaedalus.data.Vertex) (currObjet.params[0]) );
					{
						currVertex = vertex;
						iterVertexToOutEdges.set_fromVertex(currVertex);
						while (true)
						{
							currEdge = iterVertexToOutEdges.next();
							if ( ! ((( currEdge != null ))) ) 
							{
								break;
							}
							
							if (( currEdge.get_destinationVertex() == vertexUp )) 
							{
								if ( ! (currEdge.get_isConstrained()) ) 
								{
									currEdge.set_isConstrained(true);
									currEdge.get_oppositeEdge().set_isConstrained(true);
								}
								
								currEdge.addFromConstraintSegment(segment);
								currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
								vertexDown.addFromConstraintSegment(segment);
								vertexUp.addFromConstraintSegment(segment);
								segment.addEdge(currEdge);
								return segment;
							}
							
							if (( hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(currEdge.get_destinationVertex(), tempEdgeDownUp) <= 0.0001 )) 
							{
								if ( ! (currEdge.get_isConstrained()) ) 
								{
									currEdge.set_isConstrained(true);
									currEdge.get_oppositeEdge().set_isConstrained(true);
								}
								
								currEdge.addFromConstraintSegment(segment);
								currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
								vertexDown.addFromConstraintSegment(segment);
								segment.addEdge(currEdge);
								vertexDown = currEdge.get_destinationVertex();
								tempEdgeDownUp.set_originVertex(vertexDown);
								currObjet = hxDaedalus.data.math.Intersection.EVertex(vertexDown);
								done = true;
								break;
							}
							
						}
						
						if (done) 
						{
							continue;
						}
						
						iterVertexToOutEdges.set_fromVertex(currVertex);
						while (true)
						{
							currEdge = iterVertexToOutEdges.next();
							if ( ! ((( currEdge != null ))) ) 
							{
								break;
							}
							
							currEdge = currEdge.get_nextLeftEdge();
							if (hxDaedalus.data.math.Geom2D.intersections2edges(currEdge, tempEdgeDownUp, pIntersect, null, null)) 
							{
								if (currEdge.get_isConstrained()) 
								{
									vertexDown = this.splitEdge(currEdge, pIntersect.x, pIntersect.y);
									iterVertexToOutEdges.set_fromVertex(currVertex);
									while (true)
									{
										currEdge = iterVertexToOutEdges.next();
										if ( ! ((( currEdge != null ))) ) 
										{
											break;
										}
										
										if (( currEdge.get_destinationVertex() == vertexDown )) 
										{
											currEdge.set_isConstrained(true);
											currEdge.get_oppositeEdge().set_isConstrained(true);
											currEdge.addFromConstraintSegment(segment);
											currEdge.get_oppositeEdge().fromConstraintSegments = currEdge.fromConstraintSegments;
											segment.addEdge(currEdge);
											break;
										}
										
									}
									
									currVertex.addFromConstraintSegment(segment);
									tempEdgeDownUp.set_originVertex(vertexDown);
									currObjet = hxDaedalus.data.math.Intersection.EVertex(vertexDown);
								}
								else
								{
									intersectedEdges.push(currEdge);
									leftBoundingEdges.unshift(currEdge.get_nextLeftEdge());
									rightBoundingEdges.push(currEdge.get_prevLeftEdge());
									currEdge = currEdge.get_oppositeEdge();
									currObjet = hxDaedalus.data.math.Intersection.EEdge(currEdge);
								}
								
								break;
							}
							
						}
						
					}
					
					break;
				}
				
				
				case 1:
				{
					hxDaedalus.data.Edge edge = ((hxDaedalus.data.Edge) (currObjet.params[0]) );
					{
						currEdge = edge;
						edgeLeft = currEdge.get_nextLeftEdge();
						if (( edgeLeft.get_destinationVertex() == vertexUp )) 
						{
							leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
							rightBoundingEdges.push(edgeLeft);
							newEdgeDownUp = new hxDaedalus.data.Edge();
							newEdgeUpDown = new hxDaedalus.data.Edge();
							newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);
							newEdgeUpDown.setDatas(vertexUp, newEdgeDownUp, null, null, true, true);
							leftBoundingEdges.push(newEdgeDownUp);
							rightBoundingEdges.push(newEdgeUpDown);
							this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
							return segment;
						}
						else
						{
							if (( hxDaedalus.data.math.Geom2D.distanceSquaredVertexToEdge(edgeLeft.get_destinationVertex(), tempEdgeDownUp) <= 0.0001 )) 
							{
								leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
								rightBoundingEdges.push(edgeLeft);
								newEdgeDownUp = new hxDaedalus.data.Edge();
								newEdgeUpDown = new hxDaedalus.data.Edge();
								newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);
								newEdgeUpDown.setDatas(edgeLeft.get_destinationVertex(), newEdgeDownUp, null, null, true, true);
								leftBoundingEdges.push(newEdgeDownUp);
								rightBoundingEdges.push(newEdgeUpDown);
								this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
								intersectedEdges.splice(0, intersectedEdges.length);
								leftBoundingEdges.splice(0, leftBoundingEdges.length);
								rightBoundingEdges.splice(0, rightBoundingEdges.length);
								vertexDown = edgeLeft.get_destinationVertex();
								tempEdgeDownUp.set_originVertex(vertexDown);
								currObjet = hxDaedalus.data.math.Intersection.EVertex(vertexDown);
							}
							else
							{
								if (hxDaedalus.data.math.Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect, null, null)) 
								{
									if (edgeLeft.get_isConstrained()) 
									{
										currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);
										iterVertexToOutEdges.set_fromVertex(currVertex);
										while (true)
										{
											currEdge = iterVertexToOutEdges.next();
											if ( ! ((( currEdge != null ))) ) 
											{
												break;
											}
											
											if (( currEdge.get_destinationVertex() == leftBoundingEdges.__get(0).get_originVertex() )) 
											{
												leftBoundingEdges.unshift(currEdge);
											}
											
											if (( currEdge.get_destinationVertex() == rightBoundingEdges.__get(( rightBoundingEdges.length - 1 )).get_destinationVertex() )) 
											{
												rightBoundingEdges.push(currEdge.get_oppositeEdge());
											}
											
										}
										
										newEdgeDownUp = new hxDaedalus.data.Edge();
										newEdgeUpDown = new hxDaedalus.data.Edge();
										newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);
										newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);
										leftBoundingEdges.push(newEdgeDownUp);
										rightBoundingEdges.push(newEdgeUpDown);
										this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
										intersectedEdges.splice(0, intersectedEdges.length);
										leftBoundingEdges.splice(0, leftBoundingEdges.length);
										rightBoundingEdges.splice(0, rightBoundingEdges.length);
										vertexDown = currVertex;
										tempEdgeDownUp.set_originVertex(vertexDown);
										currObjet = hxDaedalus.data.math.Intersection.EVertex(vertexDown);
									}
									else
									{
										intersectedEdges.push(edgeLeft);
										leftBoundingEdges.unshift(edgeLeft.get_nextLeftEdge());
										currEdge = edgeLeft.get_oppositeEdge();
										currObjet = hxDaedalus.data.math.Intersection.EEdge(currEdge);
									}
									
								}
								else
								{
									edgeLeft = edgeLeft.get_nextLeftEdge();
									hxDaedalus.data.math.Geom2D.intersections2edges(edgeLeft, tempEdgeDownUp, pIntersect, null, null);
									if (edgeLeft.get_isConstrained()) 
									{
										currVertex = this.splitEdge(edgeLeft, pIntersect.x, pIntersect.y);
										iterVertexToOutEdges.set_fromVertex(currVertex);
										while (true)
										{
											currEdge = iterVertexToOutEdges.next();
											if ( ! ((( currEdge != null ))) ) 
											{
												break;
											}
											
											if (( currEdge.get_destinationVertex() == leftBoundingEdges.__get(0).get_originVertex() )) 
											{
												leftBoundingEdges.unshift(currEdge);
											}
											
											if (( currEdge.get_destinationVertex() == rightBoundingEdges.__get(( rightBoundingEdges.length - 1 )).get_destinationVertex() )) 
											{
												rightBoundingEdges.push(currEdge.get_oppositeEdge());
											}
											
										}
										
										newEdgeDownUp = new hxDaedalus.data.Edge();
										newEdgeUpDown = new hxDaedalus.data.Edge();
										newEdgeDownUp.setDatas(vertexDown, newEdgeUpDown, null, null, true, true);
										newEdgeUpDown.setDatas(currVertex, newEdgeDownUp, null, null, true, true);
										leftBoundingEdges.push(newEdgeDownUp);
										rightBoundingEdges.push(newEdgeUpDown);
										this.insertNewConstrainedEdge(segment, newEdgeDownUp, intersectedEdges, leftBoundingEdges, rightBoundingEdges);
										intersectedEdges.splice(0, intersectedEdges.length);
										leftBoundingEdges.splice(0, leftBoundingEdges.length);
										rightBoundingEdges.splice(0, rightBoundingEdges.length);
										vertexDown = currVertex;
										tempEdgeDownUp.set_originVertex(vertexDown);
										currObjet = hxDaedalus.data.math.Intersection.EVertex(vertexDown);
									}
									else
									{
										intersectedEdges.push(edgeLeft);
										rightBoundingEdges.push(edgeLeft.get_prevLeftEdge());
										currEdge = edgeLeft.get_oppositeEdge();
										currObjet = hxDaedalus.data.math.Intersection.EEdge(currEdge);
									}
									
								}
								
							}
							
						}
						
					}
					
					break;
				}
				
				
				case 2:
				{
					hxDaedalus.data.Face face = ((hxDaedalus.data.Face) (currObjet.params[0]) );
					break;
				}
				
				
				case 3:
				{
					break;
				}
				
				
			}
			
		}
		
	}
	
	
	public void insertNewConstrainedEdge(hxDaedalus.data.ConstraintSegment fromSegment, hxDaedalus.data.Edge edgeDownUp, haxe.root.Array<hxDaedalus.data.Edge> intersectedEdges, haxe.root.Array<hxDaedalus.data.Edge> leftBoundingEdges, haxe.root.Array<hxDaedalus.data.Edge> rightBoundingEdges)
	{
		this._edges.push(edgeDownUp);
		this._edges.push(edgeDownUp.get_oppositeEdge());
		edgeDownUp.addFromConstraintSegment(fromSegment);
		edgeDownUp.get_oppositeEdge().fromConstraintSegments = edgeDownUp.fromConstraintSegments;
		fromSegment.addEdge(edgeDownUp);
		edgeDownUp.get_originVertex().addFromConstraintSegment(fromSegment);
		edgeDownUp.get_destinationVertex().addFromConstraintSegment(fromSegment);
		this.untriangulate(intersectedEdges);
		this.triangulate(leftBoundingEdges, true);
		this.triangulate(rightBoundingEdges, true);
	}
	
	
	public void deleteConstraintSegment(hxDaedalus.data.ConstraintSegment segment)
	{
		int i = 0;
		haxe.root.Array<hxDaedalus.data.Vertex> vertexToDelete = new haxe.root.Array<hxDaedalus.data.Vertex>();
		hxDaedalus.data.Edge edge = null;
		hxDaedalus.data.Vertex vertex;
		haxe.root.Array<hxDaedalus.data.ConstraintSegment> fromConstraintSegment = null;
		{
			int _g1 = 0;
			int _g = segment.get_edges().length;
			while (( _g1 < _g ))
			{
				int i1 = _g1++;
				edge = segment.get_edges().__get(i1);
				edge.removeFromConstraintSegment(segment);
				if (( edge.fromConstraintSegments.length == 0 )) 
				{
					edge.set_isConstrained(false);
					edge.get_oppositeEdge().set_isConstrained(false);
				}
				
				vertex = edge.get_originVertex();
				vertex.removeFromConstraintSegment(segment);
				vertexToDelete.push(vertex);
			}
			
		}
		
		vertex = edge.get_destinationVertex();
		vertex.removeFromConstraintSegment(segment);
		vertexToDelete.push(vertex);
		{
			int _g11 = 0;
			int _g2 = vertexToDelete.length;
			while (( _g11 < _g2 ))
			{
				int i2 = _g11++;
				this.deleteVertex(vertexToDelete.__get(i2));
			}
			
		}
		
		segment.dispose();
	}
	
	
	public void check()
	{
		int _g1 = 0;
		int _g = this._edges.length;
		while (( _g1 < _g ))
		{
			int i = _g1++;
			if (( this._edges.__get(i).get_nextLeftEdge() == null )) 
			{
				return ;
			}
			
		}
		
	}
	
	
	public hxDaedalus.data.Vertex insertVertex(double x, double y)
	{
		if (( ( ( ( x < 0 ) || ( y < 0 ) ) || ( x > this._width ) ) || ( y > this._height ) )) 
		{
			return null;
		}
		
		this.__edgesToCheck.splice(0, this.__edgesToCheck.length);
		hxDaedalus.data.math.Intersection inObject = hxDaedalus.data.math.Geom2D.locatePosition(x, y, this);
		hxDaedalus.data.Vertex newVertex = null;
		switch (inObject.index)
		{
			case 0:
			{
				newVertex = ((Vertex) (inObject.params[0]) );
				break;
			}
			
			
			case 1:
			{
				hxDaedalus.data.Edge edge = ((hxDaedalus.data.Edge) (inObject.params[0]) );
				newVertex = this.splitEdge(edge, x, y);
				break;
			}
			
			
			case 2:
			{
				hxDaedalus.data.Face face = ((hxDaedalus.data.Face) (inObject.params[0]) );
				newVertex = this.splitFace(face, x, y);
				break;
			}
			
			
			case 3:
			{
				break;
			}
			
			
		}
		
		this.restoreAsDelaunay();
		return newVertex;
	}
	
	
	public hxDaedalus.data.Edge flipEdge(hxDaedalus.data.Edge edge)
	{
		hxDaedalus.data.Edge eTop_Bot = edge.get_oppositeEdge();
		hxDaedalus.data.Edge eLeft_Right = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eRight_Left = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eTop_Left = edge.get_nextLeftEdge();
		hxDaedalus.data.Edge eLeft_Bot = eTop_Left.get_nextLeftEdge();
		hxDaedalus.data.Edge eBot_Right = eTop_Bot.get_nextLeftEdge();
		hxDaedalus.data.Edge eRight_Top = eBot_Right.get_nextLeftEdge();
		hxDaedalus.data.Vertex vBot = edge.get_originVertex();
		hxDaedalus.data.Vertex vTop = eTop_Bot.get_originVertex();
		hxDaedalus.data.Vertex vLeft = eLeft_Bot.get_originVertex();
		hxDaedalus.data.Vertex vRight = eRight_Top.get_originVertex();
		hxDaedalus.data.Face fLeft = edge.get_leftFace();
		hxDaedalus.data.Face fRight = eTop_Bot.get_leftFace();
		hxDaedalus.data.Face fBot = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fTop = new hxDaedalus.data.Face();
		this._edges.push(eLeft_Right);
		this._edges.push(eRight_Left);
		this._faces.push(fTop);
		this._faces.push(fBot);
		eLeft_Right.setDatas(vLeft, eRight_Left, eRight_Top, fTop, edge.get_isReal(), edge.get_isConstrained());
		eRight_Left.setDatas(vRight, eLeft_Right, eLeft_Bot, fBot, edge.get_isReal(), edge.get_isConstrained());
		fTop.setDatas(eLeft_Right, null);
		fBot.setDatas(eRight_Left, null);
		if (( vTop.get_edge() == eTop_Bot )) 
		{
			vTop.setDatas(eTop_Left, null);
		}
		
		if (( vBot.get_edge() == edge))
		{
			vBot.setDatas(eBot_Right, null);
		}
		
		eTop_Left.set_nextLeftEdge(eLeft_Right);
		eTop_Left.set_leftFace(fTop);
		eLeft_Bot.set_nextLeftEdge(eBot_Right);
		eLeft_Bot.set_leftFace(fBot);
		eBot_Right.set_nextLeftEdge(eRight_Left);
		eBot_Right.set_leftFace(fBot);
		eRight_Top.set_nextLeftEdge(eTop_Left);
		eRight_Top.set_leftFace(fTop);
		edge.dispose();
		eTop_Bot.dispose();
		this._edges.splice(this._edges.indexOf(edge, null), 1);
		this._edges.splice(this._edges.indexOf(eTop_Bot, null), 1);
		fLeft.dispose();
		fRight.dispose();
		this._faces.splice(this._faces.indexOf(fLeft, null), 1);
		this._faces.splice(this._faces.indexOf(fRight, null), 1);
		return eRight_Left;
	}
	
	
	public hxDaedalus.data.Vertex splitEdge(hxDaedalus.data.Edge edge, double x, double y)
	{
		this.__edgesToCheck.splice(0, this.__edgesToCheck.length);
		hxDaedalus.data.Edge eRight_Left = edge.get_oppositeEdge();
		hxDaedalus.data.Edge eRight_Top = edge.get_nextLeftEdge();
		hxDaedalus.data.Edge eTop_Left = eRight_Top.get_nextLeftEdge();
		hxDaedalus.data.Edge eLeft_Bot = eRight_Left.get_nextLeftEdge();
		hxDaedalus.data.Edge eBot_Right = eLeft_Bot.get_nextLeftEdge();
		hxDaedalus.data.Vertex vTop = eTop_Left.get_originVertex();
		hxDaedalus.data.Vertex vLeft = edge.get_originVertex();
		hxDaedalus.data.Vertex vBot = eBot_Right.get_originVertex();
		hxDaedalus.data.Vertex vRight = eRight_Left.get_originVertex();
		hxDaedalus.data.Face fTop = edge.get_leftFace();
		hxDaedalus.data.Face fBot = eRight_Left.get_leftFace();
		if (( ( ( (( vLeft.get_pos().x - x )) * (( vLeft.get_pos().x - x )) ) + ( (( vLeft.get_pos().y - y )) * (( vLeft.get_pos().y - y )) ) ) <= 0.0001 )) 
		{
			return vLeft;
		}
		
		if (( ( ( (( vRight.get_pos().x - x )) * (( vRight.get_pos().x - x )) ) + ( (( vRight.get_pos().y - y )) * (( vRight.get_pos().y - y )) ) ) <= 0.0001 )) 
		{
			return vRight;
		}
		
		hxDaedalus.data.Vertex vCenter = new hxDaedalus.data.Vertex();
		hxDaedalus.data.Edge eTop_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Top = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eBot_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Bot = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eLeft_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Left = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eRight_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Right = new hxDaedalus.data.Edge();
		hxDaedalus.data.Face fTopLeft = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fBotLeft = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fBotRight = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fTopRight = new hxDaedalus.data.Face();
		this._vertices.push(vCenter);
		this._edges.push(eCenter_Top);
		this._edges.push(eTop_Center);
		this._edges.push(eCenter_Left);
		this._edges.push(eLeft_Center);
		this._edges.push(eCenter_Bot);
		this._edges.push(eBot_Center);
		this._edges.push(eCenter_Right);
		this._edges.push(eRight_Center);
		this._faces.push(fTopRight);
		this._faces.push(fBotRight);
		this._faces.push(fBotLeft);
		this._faces.push(fTopLeft);
		vCenter.setDatas(( (fTop.get_isReal()) ? (eCenter_Top) : (eCenter_Bot) ), null);
		vCenter.get_pos().x = x;
		vCenter.get_pos().y = y;
		hxDaedalus.data.math.Geom2D.projectOrthogonaly(vCenter.get_pos(), edge);
		eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, fTop.get_isReal(), null);
		eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, fTop.get_isReal(), null);
		eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Bot, fBotLeft, edge.get_isReal(), edge.get_isConstrained());
		eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, edge.get_isReal(), edge.get_isConstrained());
		eCenter_Bot.setDatas(vCenter, eBot_Center, eBot_Right, fBotRight, fBot.get_isReal(), null);
		eBot_Center.setDatas(vBot, eCenter_Bot, eCenter_Left, fBotLeft, fBot.get_isReal(), null);
		eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, edge.get_isReal(), edge.get_isConstrained());
		eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Bot, fBotRight, edge.get_isReal(), edge.get_isConstrained());
		fTopLeft.setDatas(eCenter_Top, fTop.get_isReal());
		fBotLeft.setDatas(eCenter_Left, fBot.get_isReal());
		fBotRight.setDatas(eCenter_Bot, fBot.get_isReal());
		fTopRight.setDatas(eCenter_Right, fTop.get_isReal());
		if (( vLeft.get_edge() == edge))
		{
			vLeft.setDatas(eLeft_Center, null);
		}
		
		if (( vRight.get_edge() == eRight_Left )) 
		{
			vRight.setDatas(eRight_Center, null);
		}
		
		eTop_Left.set_nextLeftEdge(eLeft_Center);
		eTop_Left.set_leftFace(fTopLeft);
		eLeft_Bot.set_nextLeftEdge(eBot_Center);
		eLeft_Bot.set_leftFace(fBotLeft);
		eBot_Right.set_nextLeftEdge(eRight_Center);
		eBot_Right.set_leftFace(fBotRight);
		eRight_Top.set_nextLeftEdge(eTop_Center);
		eRight_Top.set_leftFace(fTopRight);
		if (edge.get_isConstrained())
		{
			haxe.root.Array<hxDaedalus.data.ConstraintSegment> fromSegments = edge.fromConstraintSegments;
			eLeft_Center.fromConstraintSegments = fromSegments.slice(0, null);
			eCenter_Left.fromConstraintSegments = eLeft_Center.fromConstraintSegments;
			eCenter_Right.fromConstraintSegments = fromSegments.slice(0, null);
			eRight_Center.fromConstraintSegments = eCenter_Right.fromConstraintSegments;
			haxe.root.Array<hxDaedalus.data.Edge> edges;
			int index;
			{
				int _g1 = 0;
				int _g = edge.fromConstraintSegments.length;
				while (( _g1 < _g ))
				{
					int i = _g1++;
					edges = edge.fromConstraintSegments.__get(i).get_edges();
					index = edges.indexOf(edge, null);
					if (( index != -1 )) 
					{
						edges.splice(index, 1);
						edges.insert(index, eLeft_Center);
						edges.insert(( index + 1 ), eCenter_Right);
					}
					else
					{
						index = edges.indexOf(eRight_Left, null);
						edges.splice(index, 1);
						edges.insert(index, eRight_Center);
						edges.insert(( index + 1 ), eCenter_Left);
					}
					
				}
				
			}
			
			vCenter.set_fromConstraintSegments(fromSegments.slice(0, null));
		}
		
		edge.dispose();
		eRight_Left.dispose();
		this._edges.splice(this._edges.indexOf(edge, null), 1);
		this._edges.splice(this._edges.indexOf(eRight_Left, null), 1);
		fTop.dispose();
		fBot.dispose();
		this._faces.splice(this._faces.indexOf(fTop, null), 1);
		this._faces.splice(this._faces.indexOf(fBot, null), 1);
		this.__centerVertex = vCenter;
		this.__edgesToCheck.push(eTop_Left);
		this.__edgesToCheck.push(eLeft_Bot);
		this.__edgesToCheck.push(eBot_Right);
		this.__edgesToCheck.push(eRight_Top);
		return vCenter;
	}
	
	
	public hxDaedalus.data.Vertex splitFace(hxDaedalus.data.Face face, double x, double y)
	{
		this.__edgesToCheck.splice(0, this.__edgesToCheck.length);
		hxDaedalus.data.Edge eTop_Left = face.get_edge();
		hxDaedalus.data.Edge eLeft_Right = eTop_Left.get_nextLeftEdge();
		hxDaedalus.data.Edge eRight_Top = eLeft_Right.get_nextLeftEdge();
		hxDaedalus.data.Vertex vTop = eTop_Left.get_originVertex();
		hxDaedalus.data.Vertex vLeft = eLeft_Right.get_originVertex();
		hxDaedalus.data.Vertex vRight = eRight_Top.get_originVertex();
		hxDaedalus.data.Vertex vCenter = new hxDaedalus.data.Vertex();
		hxDaedalus.data.Edge eTop_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Top = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eLeft_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Left = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eRight_Center = new hxDaedalus.data.Edge();
		hxDaedalus.data.Edge eCenter_Right = new hxDaedalus.data.Edge();
		hxDaedalus.data.Face fTopLeft = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fBot = new hxDaedalus.data.Face();
		hxDaedalus.data.Face fTopRight = new hxDaedalus.data.Face();
		this._vertices.push(vCenter);
		this._edges.push(eTop_Center);
		this._edges.push(eCenter_Top);
		this._edges.push(eLeft_Center);
		this._edges.push(eCenter_Left);
		this._edges.push(eRight_Center);
		this._edges.push(eCenter_Right);
		this._faces.push(fTopLeft);
		this._faces.push(fBot);
		this._faces.push(fTopRight);
		vCenter.setDatas(eCenter_Top, null);
		vCenter.get_pos().x = x;
		vCenter.get_pos().y = y;
		eTop_Center.setDatas(vTop, eCenter_Top, eCenter_Right, fTopRight, null, null);
		eCenter_Top.setDatas(vCenter, eTop_Center, eTop_Left, fTopLeft, null, null);
		eLeft_Center.setDatas(vLeft, eCenter_Left, eCenter_Top, fTopLeft, null, null);
		eCenter_Left.setDatas(vCenter, eLeft_Center, eLeft_Right, fBot, null, null);
		eRight_Center.setDatas(vRight, eCenter_Right, eCenter_Left, fBot, null, null);
		eCenter_Right.setDatas(vCenter, eRight_Center, eRight_Top, fTopRight, null, null);
		fTopLeft.setDatas(eCenter_Top, null);
		fBot.setDatas(eCenter_Left, null);
		fTopRight.setDatas(eCenter_Right, null);
		eTop_Left.set_nextLeftEdge(eLeft_Center);
		eTop_Left.set_leftFace(fTopLeft);
		eLeft_Right.set_nextLeftEdge(eRight_Center);
		eLeft_Right.set_leftFace(fBot);
		eRight_Top.set_nextLeftEdge(eTop_Center);
		eRight_Top.set_leftFace(fTopRight);
		face.dispose();
		this._faces.splice(this._faces.indexOf(face, null), 1);
		this.__centerVertex = vCenter;
		this.__edgesToCheck.push(eTop_Left);
		this.__edgesToCheck.push(eLeft_Right);
		this.__edgesToCheck.push(eRight_Top);
		return vCenter;
	}
	
	
	public void restoreAsDelaunay()
	{
		hxDaedalus.data.Edge edge;
		while (( this.__edgesToCheck.length > 0 ))
		{
			edge = ((hxDaedalus.data.Edge) (this.__edgesToCheck.shift()) );
			if (( ( edge.get_isReal() &&  ! (edge.get_isConstrained())  ) &&  ! (hxDaedalus.data.math.Geom2D.isDelaunay(edge))  )) 
			{
				if (( edge.get_nextLeftEdge().get_destinationVertex() == this.__centerVertex )) 
				{
					this.__edgesToCheck.push(edge.get_nextRightEdge());
					this.__edgesToCheck.push(edge.get_prevRightEdge());
				}
				else
				{
					this.__edgesToCheck.push(edge.get_nextLeftEdge());
					this.__edgesToCheck.push(edge.get_prevLeftEdge());
				}
				
				this.flipEdge(edge);
			}
			
		}
		
	}
	
	
	public boolean deleteVertex(hxDaedalus.data.Vertex vertex)
	{
		int i = 0;
		boolean freeOfConstraint;
		hxDaedalus.iterators.FromVertexToOutgoingEdges iterEdges = new hxDaedalus.iterators.FromVertexToOutgoingEdges();
		iterEdges.set_fromVertex(vertex);
		iterEdges.realEdgesOnly = false;
		hxDaedalus.data.Edge edge;
		haxe.root.Array<hxDaedalus.data.Edge> outgoingEdges = new haxe.root.Array<hxDaedalus.data.Edge>();
		freeOfConstraint = ( vertex.get_fromConstraintSegments().length == 0 );
		haxe.root.Array<hxDaedalus.data.Edge> bound = new haxe.root.Array<hxDaedalus.data.Edge>();
		boolean realA = false;
		boolean realB = false;
		haxe.root.Array<hxDaedalus.data.Edge> boundA = new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{});
		haxe.root.Array<hxDaedalus.data.Edge> boundB = new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{});
		if (freeOfConstraint) 
		{
			while (true)
			{
				edge = iterEdges.next();
				if ( ! ((( edge != null ))) ) 
				{
					break;
				}
				
				outgoingEdges.push(edge);
				bound.push(edge.get_nextLeftEdge());
			}
			
		}
		else
		{
			haxe.root.Array<hxDaedalus.data.Edge> edges;
			{
				int _g1 = 0;
				int _g = vertex.get_fromConstraintSegments().length;
				while (( _g1 < _g ))
				{
					int i1 = _g1++;
					edges = vertex.get_fromConstraintSegments().__get(i1).get_edges();
					if (( ( edges.__get(0).get_originVertex() == vertex ) || ( edges.__get(( edges.length - 1 )).get_destinationVertex() == vertex ) )) 
					{
						return false;
					}
					
				}
				
			}
			
			int count = 0;
			while (true)
			{
				edge = iterEdges.next();
				if ( ! ((( edge != null ))) ) 
				{
					break;
				}
				
				outgoingEdges.push(edge);
				if (edge.get_isConstrained()) 
				{
					 ++ count;
					if (( count > 2 )) 
					{
						return false;
					}
					
				}
				
			}
			
			boundA = new haxe.root.Array<hxDaedalus.data.Edge>();
			boundB = new haxe.root.Array<hxDaedalus.data.Edge>();
			hxDaedalus.data.Edge constrainedEdgeA = null;
			hxDaedalus.data.Edge constrainedEdgeB = null;
			hxDaedalus.data.Edge edgeA = new hxDaedalus.data.Edge();
			hxDaedalus.data.Edge edgeB = new hxDaedalus.data.Edge();
			this._edges.push(edgeA);
			this._edges.push(edgeB);
			{
				int _g11 = 0;
				int _g2 = outgoingEdges.length;
				while (( _g11 < _g2 ))
				{
					int i2 = _g11++;
					edge = outgoingEdges.__get(i2);
					if (edge.get_isConstrained()) 
					{
						if (( constrainedEdgeA == null )) 
						{
							edgeB.setDatas(edge.get_destinationVertex(), edgeA, null, null, true, true);
							boundA.push(edgeA);
							boundA.push(edge.get_nextLeftEdge());
							boundB.push(edgeB);
							constrainedEdgeA = edge;
						}
						else
						{
							if (( constrainedEdgeB == null )) 
							{
								edgeA.setDatas(edge.get_destinationVertex(), edgeB, null, null, true, true);
								boundB.push(edge.get_nextLeftEdge());
								constrainedEdgeB = edge;
							}
							
						}
						
					}
					else
					{
						if (( constrainedEdgeA == null )) 
						{
							boundB.push(edge.get_nextLeftEdge());
						}
						else
						{
							if (( constrainedEdgeB == null )) 
							{
								boundA.push(edge.get_nextLeftEdge());
							}
							else
							{
								boundB.push(edge.get_nextLeftEdge());
							}
							
						}
						
					}
					
				}
				
			}
			
			realA = constrainedEdgeA.get_leftFace().get_isReal();
			realB = constrainedEdgeB.get_leftFace().get_isReal();
			edgeA.fromConstraintSegments = constrainedEdgeA.fromConstraintSegments.slice(0, null);
			edgeB.fromConstraintSegments = edgeA.fromConstraintSegments;
			int index;
			{
				int _g12 = 0;
				int _g3 = vertex.get_fromConstraintSegments().length;
				while (( _g12 < _g3 ))
				{
					int i3 = _g12++;
					edges = vertex.get_fromConstraintSegments().__get(i3).get_edges();
					index = edges.indexOf(constrainedEdgeA, null);
					if (( index != -1 )) 
					{
						edges.splice(( index - 1 ), 2);
						edges.insert(( index - 1 ), edgeA);
					}
					else
					{
						int index2 = ( edges.indexOf(constrainedEdgeB, null) - 1 );
						edges.splice(index2, 2);
						edges.insert(index2, edgeB);
					}
					
				}
				
			}
			
		}
		
		hxDaedalus.data.Face faceToDelete;
		{
			int _g13 = 0;
			int _g4 = outgoingEdges.length;
			while (( _g13 < _g4 ))
			{
				int i4 = _g13++;
				edge = outgoingEdges.__get(i4);
				faceToDelete = edge.get_leftFace();
				this._faces.splice(this._faces.indexOf(faceToDelete, null), 1);
				faceToDelete.dispose();
				edge.get_destinationVertex().set_edge(edge.get_nextLeftEdge());
				this._edges.splice(this._edges.indexOf(edge.get_oppositeEdge(), null), 1);
				edge.get_oppositeEdge().dispose();
				this._edges.splice(this._edges.indexOf(edge, null), 1);
				edge.dispose();
			}
			
		}
		
		this._vertices.splice(this._vertices.indexOf(vertex, null), 1);
		vertex.dispose();
		if (freeOfConstraint) 
		{
			this.triangulate(bound, true);
		}
		else
		{
			this.triangulate(boundA, realA);
			this.triangulate(boundB, realB);
		}
		
		return true;
	}
	
	
	public void untriangulate(haxe.root.Array<hxDaedalus.data.Edge> edgesList)
	{
		int i = 0;
		haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object> verticesCleaned = new haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object>();
		hxDaedalus.data.Edge currEdge;
		hxDaedalus.data.Edge outEdge = null;
		{
			int _g1 = 0;
			int _g = edgesList.length;
			while (( _g1 < _g ))
			{
				int i1 = _g1++;
				currEdge = edgesList.__get(i1);
				if (haxe.lang.Runtime.eq(verticesCleaned.get(currEdge.get_originVertex()), null)) 
				{
					currEdge.get_originVertex().set_edge(currEdge.get_prevLeftEdge().get_oppositeEdge());
					verticesCleaned.set(currEdge.get_originVertex(), true);
				}
				
				if (haxe.lang.Runtime.eq(verticesCleaned.get(currEdge.get_destinationVertex()), null)) 
				{
					currEdge.get_destinationVertex().set_edge(currEdge.get_nextLeftEdge());
					verticesCleaned.set(currEdge.get_destinationVertex(), true);
				}
				
				this._faces.splice(this._faces.indexOf(currEdge.get_leftFace(), null), 1);
				currEdge.get_leftFace().dispose();
				if (( i1 == ( edgesList.length - 1 ) )) 
				{
					this._faces.splice(this._faces.indexOf(currEdge.get_rightFace(), null), 1);
					currEdge.get_rightFace().dispose();
				}
				
			}
			
		}
		
		{
			int _g11 = 0;
			int _g2 = edgesList.length;
			while (( _g11 < _g2 ))
			{
				int i2 = _g11++;
				currEdge = edgesList.__get(i2);
				this._edges.splice(this._edges.indexOf(currEdge.get_oppositeEdge(), null), 1);
				this._edges.splice(this._edges.indexOf(currEdge, null), 1);
				currEdge.get_oppositeEdge().dispose();
				currEdge.dispose();
			}
			
		}
		
	}
	
	
	public void triangulate(haxe.root.Array<hxDaedalus.data.Edge> bound, boolean isReal)
	{
		if (( bound.length < 2 )) 
		{
			return ;
		}
		else
		{
			if (( bound.length == 2 )) 
			{
				java.lang.Object value = ( ( ( "  - edge0: " + bound.__get(0).get_originVertex().get_id() ) + " -> " ) + bound.__get(0).get_destinationVertex().get_id() );
				java.lang.Object value1 = ( ( ( "  - edge1: " + bound.__get(1).get_originVertex().get_id() ) + " -> " ) + bound.__get(1).get_destinationVertex().get_id() );
				return ;
			}
			else
			{
				if (( bound.length == 3 )) 
				{
					hxDaedalus.data.Face f = new hxDaedalus.data.Face();
					f.setDatas(bound.__get(0), isReal);
					this._faces.push(f);
					bound.__get(0).set_leftFace(f);
					bound.__get(1).set_leftFace(f);
					bound.__get(2).set_leftFace(f);
					bound.__get(0).set_nextLeftEdge(bound.__get(1));
					bound.__get(1).set_nextLeftEdge(bound.__get(2));
					bound.__get(2).set_nextLeftEdge(bound.__get(0));
				}
				else
				{
					hxDaedalus.data.Edge baseEdge = bound.__get(0);
					hxDaedalus.data.Vertex vertexA = baseEdge.get_originVertex();
					hxDaedalus.data.Vertex vertexB = baseEdge.get_destinationVertex();
					hxDaedalus.data.Vertex vertexC;
					hxDaedalus.data.Vertex vertexCheck;
					hxDaedalus.data.math.Point2D circumcenter = new hxDaedalus.data.math.Point2D(null, null);
					double radiusSquared;
					double distanceSquared;
					boolean isDelaunay = false;
					int index = 0;
					int i = 0;
					{
						int _g1 = 2;
						int _g = bound.length;
						while (( _g1 < _g ))
						{
							int i1 = _g1++;
							vertexC = bound.__get(i1).get_originVertex();
							if (( hxDaedalus.data.math.Geom2D.getRelativePosition2(vertexC.get_pos().x, vertexC.get_pos().y, baseEdge) == 1 )) 
							{
								index = i1;
								isDelaunay = true;
								hxDaedalus.data.math.Geom2D.getCircumcenter(vertexA.get_pos().x, vertexA.get_pos().y, vertexB.get_pos().x, vertexB.get_pos().y, vertexC.get_pos().x, vertexC.get_pos().y, circumcenter);
								radiusSquared = ( ( (( vertexA.get_pos().x - circumcenter.x )) * (( vertexA.get_pos().x - circumcenter.x )) ) + ( (( vertexA.get_pos().y - circumcenter.y )) * (( vertexA.get_pos().y - circumcenter.y )) ) );
								radiusSquared -= 0.0001;
								{
									int _g3 = 2;
									int _g2 = bound.length;
									while (( _g3 < _g2 ))
									{
										int j = _g3++;
										if (( j != i1 )) 
										{
											vertexCheck = bound.__get(j).get_originVertex();
											distanceSquared = ( ( (( vertexCheck.get_pos().x - circumcenter.x )) * (( vertexCheck.get_pos().x - circumcenter.x )) ) + ( (( vertexCheck.get_pos().y - circumcenter.y )) * (( vertexCheck.get_pos().y - circumcenter.y )) ) );
											if (( distanceSquared < radiusSquared )) 
											{
												isDelaunay = false;
												break;
											}
											
										}
										
									}
									
								}
								
								if (isDelaunay) 
								{
									break;
								}
								
							}
							
						}
						
					}
					
					if ( ! (isDelaunay) ) 
					{
						java.lang.String s = "";
						{
							int _g11 = 0;
							int _g4 = bound.length;
							while (( _g11 < _g4 ))
							{
								int i2 = _g11++;
								s += ( haxe.lang.Runtime.toString(bound.__get(i2).get_originVertex().get_pos().x) + " , " );
								s += ( haxe.lang.Runtime.toString(bound.__get(i2).get_originVertex().get_pos().y) + " , " );
								s += ( haxe.lang.Runtime.toString(bound.__get(i2).get_destinationVertex().get_pos().x) + " , " );
								s += ( haxe.lang.Runtime.toString(bound.__get(i2).get_destinationVertex().get_pos().y) + " , " );
							}
							
						}
						
						index = 2;
					}
					
					hxDaedalus.data.Edge edgeA;
					hxDaedalus.data.Edge edgeAopp = null;
					hxDaedalus.data.Edge edgeB = null;
					hxDaedalus.data.Edge edgeBopp;
					haxe.root.Array<hxDaedalus.data.Edge> boundA;
					haxe.root.Array<hxDaedalus.data.Edge> boundM;
					haxe.root.Array<hxDaedalus.data.Edge> boundB;
					if (( index < ( bound.length - 1 ) )) 
					{
						edgeA = new hxDaedalus.data.Edge();
						edgeAopp = new hxDaedalus.data.Edge();
						this._edges.push(edgeA);
						this._edges.push(edgeAopp);
						edgeA.setDatas(vertexA, edgeAopp, null, null, isReal, false);
						edgeAopp.setDatas(bound.__get(index).get_originVertex(), edgeA, null, null, isReal, false);
						boundA = bound.slice(index, null);
						boundA.push(edgeA);
						this.triangulate(boundA, isReal);
					}
					
					if (( index > 2 )) 
					{
						edgeB = new hxDaedalus.data.Edge();
						edgeBopp = new hxDaedalus.data.Edge();
						this._edges.push(edgeB);
						this._edges.push(edgeBopp);
						edgeB.setDatas(bound.__get(1).get_originVertex(), edgeBopp, null, null, isReal, false);
						edgeBopp.setDatas(bound.__get(index).get_originVertex(), edgeB, null, null, isReal, false);
						boundB = bound.slice(1, index);
						boundB.push(edgeBopp);
						this.triangulate(boundB, isReal);
					}
					
					if (( index == 2 )) 
					{
						boundM = new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{baseEdge, bound.__get(1), edgeAopp});
					}
					else
					{
						if (( index == ( bound.length - 1 ) )) 
						{
							boundM = new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{baseEdge, edgeB, bound.__get(index)});
						}
						else
						{
							boundM = new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{baseEdge, edgeB, edgeAopp});
						}
						
					}
					
					this.triangulate(boundM, isReal);
				}
				
			}
			
		}
		
	}
	
	
	public int findPositionFromBounds(double x, double y)
	{
		if (( x <= 0 )) 
		{
			if (( y <= 0 )) 
			{
				return 1;
			}
			else
			{
				if (( y >= this._height )) 
				{
					return 7;
				}
				else
				{
					return 8;
				}
				
			}
			
		}
		else
		{
			if (( x >= this._width )) 
			{
				if (( y <= 0 )) 
				{
					return 3;
				}
				else
				{
					if (( y >= this._height )) 
					{
						return 5;
					}
					else
					{
						return 4;
					}
					
				}
				
			}
			else
			{
				if (( y <= 0 )) 
				{
					return 2;
				}
				else
				{
					if (( y >= this._height )) 
					{
						return 6;
					}
					else
					{
						return 0;
					}
					
				}
				
			}
			
		}
		
	}
	
	
	public void debug()
	{
		int i = 0;
		{
			int _g1 = 0;
			int _g = this._vertices.length;
			while (( _g1 < _g ))
			{
				int i1 = _g1++;
				java.lang.Object value = ( "-- vertex " + this._vertices.__get(i1).get_id() );
				java.lang.Object value1 = ( ( ( "  edge " + this._vertices.__get(i1).get_edge().get_id() ) + " - " ) + haxe.root.Std.string(this._vertices.__get(i1).get_edge()) );
				java.lang.Object value2 = ( "  edge isReal: " + haxe.root.Std.string(this._vertices.__get(i1).get_edge().get_isReal()) );
			}
			
		}
		
		{
			int _g11 = 0;
			int _g2 = this._edges.length;
			while (( _g11 < _g2 ))
			{
				int i2 = _g11++;
				java.lang.Object value3 = ( "-- edge " + haxe.root.Std.string(this._edges.__get(i2)) );
				java.lang.Object value4 = ( ( ( "  isReal " + this._edges.__get(i2).get_id() ) + " - " ) + haxe.root.Std.string(this._edges.__get(i2).get_isReal()) );
				java.lang.Object value5 = ( "  nextLeftEdge " + haxe.root.Std.string(this._edges.__get(i2).get_nextLeftEdge()) );
				java.lang.Object value6 = ( "  oppositeEdge " + haxe.root.Std.string(this._edges.__get(i2).get_oppositeEdge()) );
			}
			
		}
		
	}
	
	
	public java.lang.Object getVerticesAndEdges()
	{
		java.lang.Object res = new haxe.lang.DynamicObject(new java.lang.String[]{"edges", "vertices"}, new java.lang.Object[]{new haxe.root.Array<hxDaedalus.data.Edge>(new hxDaedalus.data.Edge[]{}), new haxe.root.Array<hxDaedalus.data.Vertex>(new hxDaedalus.data.Vertex[]{})}, new java.lang.String[]{}, new double[]{});
		hxDaedalus.data.Vertex vertex;
		hxDaedalus.data.Edge incomingEdge;
		hxDaedalus.data.Face holdingFace = null;
		hxDaedalus.iterators.FromMeshToVertices iterVertices = new hxDaedalus.iterators.FromMeshToVertices();
		iterVertices.set_fromMesh(this);
		hxDaedalus.iterators.FromVertexToIncomingEdges iterEdges = new hxDaedalus.iterators.FromVertexToIncomingEdges();
		haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object> dictVerticesDone = new haxe.ds.ObjectMap<hxDaedalus.data.Vertex, java.lang.Object>();
		while (true)
		{
			vertex = iterVertices.next();
			if ( ! ((( vertex != null ))) ) 
			{
				break;
			}
			
			dictVerticesDone.set(vertex, true);
			if ( ! (( ! ((( ( ( ( vertex.get_pos().x < 0 ) || ( vertex.get_pos().x > this.get_width() ) ) || ( vertex.get_pos().y < 0 ) ) || ( vertex.get_pos().y > this.get_height() ) ))) )) ) 
			{
				continue;
			}
			
			((haxe.root.Array<hxDaedalus.data.Vertex>) (haxe.lang.Runtime.getField(res, "vertices", true)) ).push(vertex);
			iterEdges.set_fromVertex(vertex);
			while (true)
			{
				incomingEdge = iterEdges.next();
				if ( ! ((( incomingEdge != null ))) ) 
				{
					break;
				}
				
				if (( ! (haxe.lang.Runtime.toBool(dictVerticesDone.get(incomingEdge.get_originVertex()))) )) 
				{
					((haxe.root.Array<hxDaedalus.data.Edge>) (haxe.lang.Runtime.getField(res, "edges", true)) ).push(incomingEdge);
				}
				
			}
			
		}
		
		return res;
	}
	
	
	public final boolean vertexIsInsideAABB(hxDaedalus.data.Vertex vertex, hxDaedalus.data.Mesh mesh)
	{
		return  ! ((( ( ( ( vertex.get_pos().x < 0 ) || ( vertex.get_pos().x > mesh.get_width() ) ) || ( vertex.get_pos().y < 0 ) ) || ( vertex.get_pos().y > mesh.get_height() ) ))) ;
	}
	
	
	@Override public double __hx_setField_f(java.lang.String field, double value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1487441478:
				{
					if (field.equals("_height")) 
					{
						this._height = value;
						return value;
					}
					
					break;
				}
				
				
				case 94650:
				{
					if (field.equals("_id")) 
					{
						this._id = ((int) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1462071097:
				{
					if (field.equals("_width")) 
					{
						this._width = value;
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField_f(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_setField(java.lang.String field, java.lang.Object value, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case -542726801:
				{
					if (field.equals("__objectsUpdateInProgress")) 
					{
						this.__objectsUpdateInProgress = haxe.lang.Runtime.toBool(value);
						return value;
					}
					
					break;
				}
				
				
				case 918617282:
				{
					if (field.equals("clipping")) 
					{
						this.set_clipping(haxe.lang.Runtime.toBool(value));
						return value;
					}
					
					break;
				}
				
				
				case 367204343:
				{
					if (field.equals("__edgesToCheck")) 
					{
						this.__edgesToCheck = ((haxe.root.Array<hxDaedalus.data.Edge>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 94650:
				{
					if (field.equals("_id")) 
					{
						this._id = haxe.lang.Runtime.toInt(value);
						return value;
					}
					
					break;
				}
				
				
				case 1431196217:
				{
					if (field.equals("__centerVertex")) 
					{
						this.__centerVertex = ((hxDaedalus.data.Vertex) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1462071097:
				{
					if (field.equals("_width")) 
					{
						this._width = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case 698575829:
				{
					if (field.equals("_objects")) 
					{
						this._objects = ((haxe.root.Array<hxDaedalus.data.Obstacle>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 1487441478:
				{
					if (field.equals("_height")) 
					{
						this._height = haxe.lang.Runtime.toDouble(value);
						return value;
					}
					
					break;
				}
				
				
				case -1416138866:
				{
					if (field.equals("_constraintShapes")) 
					{
						this._constraintShapes = ((haxe.root.Array<hxDaedalus.data.ConstraintShape>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case 1009135137:
				{
					if (field.equals("_clipping")) 
					{
						this._clipping = haxe.lang.Runtime.toBool(value);
						return value;
					}
					
					break;
				}
				
				
				case -1478010697:
				{
					if (field.equals("_faces")) 
					{
						this._faces = ((haxe.root.Array<hxDaedalus.data.Face>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1893623464:
				{
					if (field.equals("_vertices")) 
					{
						this._vertices = ((haxe.root.Array<hxDaedalus.data.Vertex>) (value) );
						return value;
					}
					
					break;
				}
				
				
				case -1478841001:
				{
					if (field.equals("_edges")) 
					{
						this._edges = ((haxe.root.Array<hxDaedalus.data.Edge>) (value) );
						return value;
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_setField(field, value, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_getField(java.lang.String field, boolean throwErrors, boolean isCheck, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 37005034:
				{
					if (field.equals("vertexIsInsideAABB")) 
					{
						return new haxe.lang.Closure(this, "vertexIsInsideAABB");
					}
					
					break;
				}
				
				
				case -1221029593:
				{
					if (field.equals("height")) 
					{
						return this.get_height();
					}
					
					break;
				}
				
				
				case 1049073998:
				{
					if (field.equals("getVerticesAndEdges")) 
					{
						return new haxe.lang.Closure(this, "getVerticesAndEdges");
					}
					
					break;
				}
				
				
				case 113126854:
				{
					if (field.equals("width")) 
					{
						return this.get_width();
					}
					
					break;
				}
				
				
				case 95458899:
				{
					if (field.equals("debug")) 
					{
						return new haxe.lang.Closure(this, "debug");
					}
					
					break;
				}
				
				
				case 918617282:
				{
					if (field.equals("clipping")) 
					{
						return this.get_clipping();
					}
					
					break;
				}
				
				
				case -1886126431:
				{
					if (field.equals("findPositionFromBounds")) 
					{
						return new haxe.lang.Closure(this, "findPositionFromBounds");
					}
					
					break;
				}
				
				
				case 3355:
				{
					if (field.equals("id")) 
					{
						return this.get_id();
					}
					
					break;
				}
				
				
				case -569584212:
				{
					if (field.equals("triangulate")) 
					{
						return new haxe.lang.Closure(this, "triangulate");
					}
					
					break;
				}
				
				
				case -1648731889:
				{
					if (field.equals("__constraintShapes")) 
					{
						return this.get___constraintShapes();
					}
					
					break;
				}
				
				
				case 776199539:
				{
					if (field.equals("untriangulate")) 
					{
						return new haxe.lang.Closure(this, "untriangulate");
					}
					
					break;
				}
				
				
				case 94650:
				{
					if (field.equals("_id")) 
					{
						return this._id;
					}
					
					break;
				}
				
				
				case -687999185:
				{
					if (field.equals("deleteVertex")) 
					{
						return new haxe.lang.Closure(this, "deleteVertex");
					}
					
					break;
				}
				
				
				case -1462071097:
				{
					if (field.equals("_width")) 
					{
						return this._width;
					}
					
					break;
				}
				
				
				case 206143175:
				{
					if (field.equals("restoreAsDelaunay")) 
					{
						return new haxe.lang.Closure(this, "restoreAsDelaunay");
					}
					
					break;
				}
				
				
				case 1487441478:
				{
					if (field.equals("_height")) 
					{
						return this._height;
					}
					
					break;
				}
				
				
				case 403916951:
				{
					if (field.equals("splitFace")) 
					{
						return new haxe.lang.Closure(this, "splitFace");
					}
					
					break;
				}
				
				
				case 1009135137:
				{
					if (field.equals("_clipping")) 
					{
						return this._clipping;
					}
					
					break;
				}
				
				
				case 403890167:
				{
					if (field.equals("splitEdge")) 
					{
						return new haxe.lang.Closure(this, "splitEdge");
					}
					
					break;
				}
				
				
				case -1893623464:
				{
					if (field.equals("_vertices")) 
					{
						return this._vertices;
					}
					
					break;
				}
				
				
				case 1850794954:
				{
					if (field.equals("flipEdge")) 
					{
						return new haxe.lang.Closure(this, "flipEdge");
					}
					
					break;
				}
				
				
				case -1478841001:
				{
					if (field.equals("_edges")) 
					{
						return this._edges;
					}
					
					break;
				}
				
				
				case 826126781:
				{
					if (field.equals("insertVertex")) 
					{
						return new haxe.lang.Closure(this, "insertVertex");
					}
					
					break;
				}
				
				
				case -1478010697:
				{
					if (field.equals("_faces")) 
					{
						return this._faces;
					}
					
					break;
				}
				
				
				case 94627080:
				{
					if (field.equals("check")) 
					{
						return new haxe.lang.Closure(this, "check");
					}
					
					break;
				}
				
				
				case -1416138866:
				{
					if (field.equals("_constraintShapes")) 
					{
						return this._constraintShapes;
					}
					
					break;
				}
				
				
				case 997368875:
				{
					if (field.equals("deleteConstraintSegment")) 
					{
						return new haxe.lang.Closure(this, "deleteConstraintSegment");
					}
					
					break;
				}
				
				
				case 698575829:
				{
					if (field.equals("_objects")) 
					{
						return this._objects;
					}
					
					break;
				}
				
				
				case 1763944460:
				{
					if (field.equals("insertNewConstrainedEdge")) 
					{
						return new haxe.lang.Closure(this, "insertNewConstrainedEdge");
					}
					
					break;
				}
				
				
				case 1431196217:
				{
					if (field.equals("__centerVertex")) 
					{
						return this.__centerVertex;
					}
					
					break;
				}
				
				
				case -1434164003:
				{
					if (field.equals("insertConstraintSegment")) 
					{
						return new haxe.lang.Closure(this, "insertConstraintSegment");
					}
					
					break;
				}
				
				
				case 367204343:
				{
					if (field.equals("__edgesToCheck")) 
					{
						return this.__edgesToCheck;
					}
					
					break;
				}
				
				
				case 528495257:
				{
					if (field.equals("deleteConstraintShape")) 
					{
						return new haxe.lang.Closure(this, "deleteConstraintShape");
					}
					
					break;
				}
				
				
				case 859648560:
				{
					if (field.equals("get_height")) 
					{
						return new haxe.lang.Closure(this, "get_height");
					}
					
					break;
				}
				
				
				case -1190234165:
				{
					if (field.equals("insertConstraintShape")) 
					{
						return new haxe.lang.Closure(this, "insertConstraintShape");
					}
					
					break;
				}
				
				
				case 1150076829:
				{
					if (field.equals("get_width")) 
					{
						return new haxe.lang.Closure(this, "get_width");
					}
					
					break;
				}
				
				
				case 1139367947:
				{
					if (field.equals("updateObjects")) 
					{
						return new haxe.lang.Closure(this, "updateObjects");
					}
					
					break;
				}
				
				
				case -1004437621:
				{
					if (field.equals("get_clipping")) 
					{
						return new haxe.lang.Closure(this, "get_clipping");
					}
					
					break;
				}
				
				
				case -542726801:
				{
					if (field.equals("__objectsUpdateInProgress")) 
					{
						return this.__objectsUpdateInProgress;
					}
					
					break;
				}
				
				
				case 544555007:
				{
					if (field.equals("set_clipping")) 
					{
						return new haxe.lang.Closure(this, "set_clipping");
					}
					
					break;
				}
				
				
				case -891426614:
				{
					if (field.equals("deleteObject")) 
					{
						return new haxe.lang.Closure(this, "deleteObject");
					}
					
					break;
				}
				
				
				case -1249338716:
				{
					if (field.equals("get_id")) 
					{
						return new haxe.lang.Closure(this, "get_id");
					}
					
					break;
				}
				
				
				case 622699352:
				{
					if (field.equals("insertObject")) 
					{
						return new haxe.lang.Closure(this, "insertObject");
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						return new haxe.lang.Closure(this, "dispose");
					}
					
					break;
				}
				
				
				case -784041559:
				{
					if (field.equals("buildFromRecord")) 
					{
						return new haxe.lang.Closure(this, "buildFromRecord");
					}
					
					break;
				}
				
				
				case -42945384:
				{
					if (field.equals("get___constraintShapes")) 
					{
						return new haxe.lang.Closure(this, "get___constraintShapes");
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField(field, throwErrors, isCheck, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public double __hx_getField_f(java.lang.String field, boolean throwErrors, boolean handleProperties)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 1487441478:
				{
					if (field.equals("_height")) 
					{
						return this._height;
					}
					
					break;
				}
				
				
				case -1221029593:
				{
					if (field.equals("height")) 
					{
						return this.get_height();
					}
					
					break;
				}
				
				
				case -1462071097:
				{
					if (field.equals("_width")) 
					{
						return this._width;
					}
					
					break;
				}
				
				
				case 113126854:
				{
					if (field.equals("width")) 
					{
						return this.get_width();
					}
					
					break;
				}
				
				
				case 94650:
				{
					if (field.equals("_id")) 
					{
						return this._id;
					}
					
					break;
				}
				
				
				case 3355:
				{
					if (field.equals("id")) 
					{
						return this.get_id();
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_getField_f(field, throwErrors, handleProperties);
			}
			else
			{
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_invokeField(java.lang.String field, haxe.root.Array dynargs)
	{
		{
			boolean __temp_executeDef1 = true;
			switch (field.hashCode())
			{
				case 37005034:
				{
					if (field.equals("vertexIsInsideAABB")) 
					{
						return this.vertexIsInsideAABB(((hxDaedalus.data.Vertex) (dynargs.__get(0)) ), ((hxDaedalus.data.Mesh) (dynargs.__get(1)) ));
					}
					
					break;
				}
				
				
				case 859648560:
				{
					if (field.equals("get_height")) 
					{
						return this.get_height();
					}
					
					break;
				}
				
				
				case 1049073998:
				{
					if (field.equals("getVerticesAndEdges")) 
					{
						return this.getVerticesAndEdges();
					}
					
					break;
				}
				
				
				case 1150076829:
				{
					if (field.equals("get_width")) 
					{
						return this.get_width();
					}
					
					break;
				}
				
				
				case 95458899:
				{
					if (field.equals("debug")) 
					{
						__temp_executeDef1 = false;
						this.debug();
					}
					
					break;
				}
				
				
				case -1004437621:
				{
					if (field.equals("get_clipping")) 
					{
						return this.get_clipping();
					}
					
					break;
				}
				
				
				case -1886126431:
				{
					if (field.equals("findPositionFromBounds")) 
					{
						return this.findPositionFromBounds(haxe.lang.Runtime.toDouble(dynargs.__get(0)), haxe.lang.Runtime.toDouble(dynargs.__get(1)));
					}
					
					break;
				}
				
				
				case 544555007:
				{
					if (field.equals("set_clipping")) 
					{
						return this.set_clipping(haxe.lang.Runtime.toBool(dynargs.__get(0)));
					}
					
					break;
				}
				
				
				case -569584212:
				{
					if (field.equals("triangulate")) 
					{
						__temp_executeDef1 = false;
						this.triangulate(((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(0)) ), haxe.lang.Runtime.toBool(dynargs.__get(1)));
					}
					
					break;
				}
				
				
				case -1249338716:
				{
					if (field.equals("get_id")) 
					{
						return this.get_id();
					}
					
					break;
				}
				
				
				case 776199539:
				{
					if (field.equals("untriangulate")) 
					{
						__temp_executeDef1 = false;
						this.untriangulate(((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 1671767583:
				{
					if (field.equals("dispose")) 
					{
						__temp_executeDef1 = false;
						this.dispose();
					}
					
					break;
				}
				
				
				case -687999185:
				{
					if (field.equals("deleteVertex")) 
					{
						return this.deleteVertex(((hxDaedalus.data.Vertex) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case -42945384:
				{
					if (field.equals("get___constraintShapes")) 
					{
						return this.get___constraintShapes();
					}
					
					break;
				}
				
				
				case 206143175:
				{
					if (field.equals("restoreAsDelaunay")) 
					{
						__temp_executeDef1 = false;
						this.restoreAsDelaunay();
					}
					
					break;
				}
				
				
				case -784041559:
				{
					if (field.equals("buildFromRecord")) 
					{
						__temp_executeDef1 = false;
						this.buildFromRecord(haxe.lang.Runtime.toString(dynargs.__get(0)));
					}
					
					break;
				}
				
				
				case 403916951:
				{
					if (field.equals("splitFace")) 
					{
						return this.splitFace(((hxDaedalus.data.Face) (dynargs.__get(0)) ), haxe.lang.Runtime.toDouble(dynargs.__get(1)), haxe.lang.Runtime.toDouble(dynargs.__get(2)));
					}
					
					break;
				}
				
				
				case 622699352:
				{
					if (field.equals("insertObject")) 
					{
						__temp_executeDef1 = false;
						this.insertObject(((hxDaedalus.data.Obstacle) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 403890167:
				{
					if (field.equals("splitEdge")) 
					{
						return this.splitEdge(((hxDaedalus.data.Edge) (dynargs.__get(0)) ), haxe.lang.Runtime.toDouble(dynargs.__get(1)), haxe.lang.Runtime.toDouble(dynargs.__get(2)));
					}
					
					break;
				}
				
				
				case -891426614:
				{
					if (field.equals("deleteObject")) 
					{
						__temp_executeDef1 = false;
						this.deleteObject(((hxDaedalus.data.Obstacle) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 1850794954:
				{
					if (field.equals("flipEdge")) 
					{
						return this.flipEdge(((hxDaedalus.data.Edge) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 1139367947:
				{
					if (field.equals("updateObjects")) 
					{
						__temp_executeDef1 = false;
						this.updateObjects();
					}
					
					break;
				}
				
				
				case 826126781:
				{
					if (field.equals("insertVertex")) 
					{
						return this.insertVertex(haxe.lang.Runtime.toDouble(dynargs.__get(0)), haxe.lang.Runtime.toDouble(dynargs.__get(1)));
					}
					
					break;
				}
				
				
				case -1190234165:
				{
					if (field.equals("insertConstraintShape")) 
					{
						return this.insertConstraintShape(((haxe.root.Array<java.lang.Object>) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 94627080:
				{
					if (field.equals("check")) 
					{
						__temp_executeDef1 = false;
						this.check();
					}
					
					break;
				}
				
				
				case 528495257:
				{
					if (field.equals("deleteConstraintShape")) 
					{
						__temp_executeDef1 = false;
						this.deleteConstraintShape(((hxDaedalus.data.ConstraintShape) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case 997368875:
				{
					if (field.equals("deleteConstraintSegment")) 
					{
						__temp_executeDef1 = false;
						this.deleteConstraintSegment(((hxDaedalus.data.ConstraintSegment) (dynargs.__get(0)) ));
					}
					
					break;
				}
				
				
				case -1434164003:
				{
					if (field.equals("insertConstraintSegment")) 
					{
						return this.insertConstraintSegment(haxe.lang.Runtime.toDouble(dynargs.__get(0)), haxe.lang.Runtime.toDouble(dynargs.__get(1)), haxe.lang.Runtime.toDouble(dynargs.__get(2)), haxe.lang.Runtime.toDouble(dynargs.__get(3)));
					}
					
					break;
				}
				
				
				case 1763944460:
				{
					if (field.equals("insertNewConstrainedEdge")) 
					{
						__temp_executeDef1 = false;
						this.insertNewConstrainedEdge(((hxDaedalus.data.ConstraintSegment) (dynargs.__get(0)) ), ((hxDaedalus.data.Edge) (dynargs.__get(1)) ), ((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(2)) ), ((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(3)) ), ((haxe.root.Array<hxDaedalus.data.Edge>) (dynargs.__get(4)) ));
					}
					
					break;
				}
				
				
			}
			
			if (__temp_executeDef1) 
			{
				return super.__hx_invokeField(field, dynargs);
			}
			
		}
		
		return null;
	}
	
	
	@Override public void __hx_getFields(haxe.root.Array<java.lang.String> baseArr)
	{
		baseArr.push("__objectsUpdateInProgress");
		baseArr.push("__edgesToCheck");
		baseArr.push("__centerVertex");
		baseArr.push("_objects");
		baseArr.push("_constraintShapes");
		baseArr.push("_faces");
		baseArr.push("_edges");
		baseArr.push("_vertices");
		baseArr.push("_clipping");
		baseArr.push("_height");
		baseArr.push("_width");
		baseArr.push("_id");
		baseArr.push("__constraintShapes");
		baseArr.push("id");
		baseArr.push("clipping");
		baseArr.push("width");
		baseArr.push("height");
		super.__hx_getFields(baseArr);
	}
	
	
}


